const STRAT_RANDOM=.1,BOARD_SIZE=11;let gameState={currentPlayer:1,phase:"setup",turn:1,board:Array(11).fill().map(()=>Array(11).fill(null)),players:{1:{hand:[],captured:[],discarded:[],deck:[],leader:null,leaderPosition:null},2:{hand:[],captured:[],discarded:[],deck:[],leader:null,leaderPosition:null}},selectedCard:null,selectedHex:null,selectedCards:[],validMoves:[],validAttacks:[],blockedMoves:[],absorptions:[],setupStep:"place-cards",setupCardsPlaced:{1:0,2:0},setupLeaderPlaced:{1:!1,2:!1},leaderAttackedThisTurn:!1,cardsMovedThisTurn:new Set,cardsAttackedThisTurn:new Set,cardsAttackExhaustion:new Map,moveCount:1,firstPlayer:1},fadeOutElements=[],gameHistory=[];const MAX_HISTORY_SIZE=10;let canvas,ctx,hexWidth,hexHeight,boardOffsetX,boardOffsetY,aiThinkingState={isThinking:!1,player:null,phase:"",progress:0,maxProgress:100,currentAction:"",startTime:null,thinkingDots:0},hexSize=22,baseHexSize=22,zoomLevel=1,mapRotated=!1,mapFlippingEnabled=!0,aiEnabled={1:!1,2:!0};function getCardForAI(e,t){return e.faceDown&&e.owner!==t?{...e,value:"?",suit:"unknown",attack:3,defense:3,isAIHidden:!0}:e}const BASE_AGG=70,EXTRA_AGG=30;let aiAggression={1:0,2:0};function initializeAIAggression(){for(let e=1;e<=2;e++)if(aiEnabled[e]){const t=Math.floor(31*Math.random());aiAggression[e]=70+t,console.log(`AI Player ${e} aggression level: ${aiAggression[e]}/100 (Base: 70, Extra: ${t})`)}else aiAggression[e]=0}function getAggressionModifier(e){if(!aiEnabled[e])return 1;return.5+aiAggression[e]/100*1.5}function hasAnyAI(){return aiEnabled[1]||aiEnabled[2]}function isBotVsBot(){return aiEnabled[1]&&aiEnabled[2]}let wakeLock=null,wakeLockSupported="wakeLock"in navigator;async function requestWakeLock(){if(!wakeLockSupported)return console.log("Wake Lock API not supported, using fallback methods"),!1;try{return wakeLock=await navigator.wakeLock.request("screen"),console.log("Screen wake lock activated for AI vs AI mode"),wakeLock.addEventListener("release",()=>{console.log("Screen wake lock released")}),!0}catch(e){return console.error("Failed to request wake lock:",e),!1}}async function releaseWakeLock(){if(wakeLock)try{await wakeLock.release(),wakeLock=null,console.log("Screen wake lock manually released")}catch(e){console.error("Failed to release wake lock:",e)}}let keepAliveInterval=null;function startKeepAlive(){if(keepAliveInterval)return;const e=document.createElement("video");e.style.position="absolute",e.style.top="-1px",e.style.left="-1px",e.style.width="1px",e.style.height="1px",e.style.opacity="0.01",e.muted=!0,e.loop=!0,e.autoplay=!0,e.id="keepAliveVideo";const t=document.createElement("canvas");t.width=1,t.height=1;const a=t.getContext("2d");a.fillStyle="#000000",a.fillRect(0,0,1,1),t.toBlob(t=>{const a=URL.createObjectURL(t);e.src=a,document.body.appendChild(e),e.play().catch(e=>console.log("Fallback keep-alive video failed:",e))}),keepAliveInterval=setInterval(()=>{document.body.style.background=document.body.style.background},3e4),console.log("Started fallback keep-alive methods")}function stopKeepAlive(){keepAliveInterval&&(clearInterval(keepAliveInterval),keepAliveInterval=null);const e=document.getElementById("keepAliveVideo");e&&e.remove(),console.log("Stopped fallback keep-alive methods")}async function updateScreenWakeLock(){if(isBotVsBot()&&"play"===gameState.phase){if(!wakeLock){await requestWakeLock()||startKeepAlive()}}else await releaseWakeLock(),stopKeepAlive()}function updateMapFlippingForAI(){const e=(aiEnabled[1]?1:0)+(aiEnabled[2]?1:0);if(mapFlippingEnabled=0===e,mapFlippingEnabled)updateMapRotation();else if(1===e){const e=aiEnabled[1]?2:1;mapRotated=1===e}else mapRotated=!0;if(updateCanvas(),mapFlippingEnabled)console.log("Map flipping enabled - map rotates based on current player (human vs human)");else if(1===e){const e=aiEnabled[1]?2:1;console.log(`Map flipping disabled - map locked to human player ${e}'s perspective (human vs AI)`)}else console.log("Map flipping disabled - map locked to Player 1's perspective (AI vs AI spectating)")}function updateMapRotation(){mapFlippingEnabled?("play"===gameState.phase||"setup"===gameState.phase)&&(mapRotated=1===gameState.currentPlayer):mapRotated=!0}function startPlayingMode(){localStorage.setItem("tcg-has-interacted","true");const e=document.getElementById("try-playing-btn");e&&e.classList.add("hidden"),aiEnabled[1]=!1,aiEnabled[2]=!0,updateMapFlippingForAI(),updateAllAIButtons(),resetGame(),console.log("Switched to human vs bot mode")}function toggleAIPlayer(e){localStorage.setItem("tcg-has-interacted","true"),aiEnabled[e]=!aiEnabled[e],updateMapFlippingForAI(),updateScreenWakeLock(),updateAllAIButtons(),saveGameState(),console.log(`Player ${e} AI ${aiEnabled[e]?"enabled":"disabled"}`),aiEnabled[e]&&gameState.currentPlayer===e&&"play"===gameState.phase&&setTimeout(()=>{performAIMove(e)},300)}function updateAIButton(e){const t=document.getElementById(`ai-p${e}-toggle-btn`);if(t){const a=aiEnabled[e]?"ON":"OFF",o=hasAnyAI()?" ðŸ”’":" ðŸ”„";t.textContent=`ðŸ¤– P${e} AI: ${a}${o}`}}function updateAllAIButtons(){updateAIButton(1),updateAIButton(2)}function performAIMove(e){console.log(`performAIMove called for player ${e}`),aiEnabled[e]&&gameState.currentPlayer===e&&"play"===gameState.phase?(console.log(`AI Player ${e} starting turn ${gameState.turn}...`),startAIThinking(e,"play",6),aiTurnTimeout&&clearTimeout(aiTurnTimeout),aiTurnTimeout=setTimeout(()=>{console.log(`Emergency timeout: AI Player ${e} taking too long, forcing end turn`);const t=`${e}-${gameState.turn}`;aiActionCount.delete(t),endTurn()},3e4),performAITurnSequence(e)):console.log(`AI Move cancelled: aiEnabled=${aiEnabled[e]}, currentPlayer=${gameState.currentPlayer}, phase=${gameState.phase}`)}let aiActionCount=new Map,aiTurnTimeout=null,lastAIAction=null;function startAIThinking(e,t,a=5){aiThinkingState={isThinking:!0,player:e,phase:t,progress:0,maxProgress:a,currentAction:"Analyzing board...",startTime:Date.now(),thinkingDots:0},updateAIThinkingDisplay()}function updateAIThinking(e,t=null){aiThinkingState.isThinking&&(aiThinkingState.currentAction=e,null!==t&&(aiThinkingState.progress=Math.min(t,aiThinkingState.maxProgress)),updateAIThinkingDisplay())}function stopAIThinking(){aiThinkingState.isThinking=!1,updateAIThinkingDisplay()}function updateAIThinkingDisplay(){aiThinkingState.isThinking&&(aiThinkingState.thinkingDots=(aiThinkingState.thinkingDots+1)%4,updateUI(),setTimeout(()=>{aiThinkingState.isThinking&&updateAIThinkingDisplay()},500))}function shouldRandomizeStrategy(){return Math.random()<.1}function addRandomNoise(e,t=50){return e+2*(Math.random()-.5)*t}function shuffleArray(e){const t=[...e];for(let e=t.length-1;e>0;e--){const a=Math.floor(Math.random()*(e+1));[t[e],t[a]]=[t[a],t[e]]}return t}function performAITurnSequence(e){if(console.log(`performAITurnSequence called for player ${e}`),!aiEnabled[e]||gameState.currentPlayer!==e||"play"!==gameState.phase)return void console.log(`AI Turn Sequence cancelled: aiEnabled=${aiEnabled[e]}, currentPlayer=${gameState.currentPlayer}, phase=${gameState.phase}`);const t=`${e}-${gameState.turn}`;aiActionCount.has(t)||aiActionCount.set(t,0);const a=aiActionCount.get(t);if(a>=20)return console.log(`AI Player ${e} reached max actions (20), ending turn`),aiActionCount.delete(t),void setTimeout(()=>endTurn(),300);const o=gameState.moveCount>=80,r=e===gameState.firstPlayer;updateAIThinking("Checking leader safety...",1);const n=findBestLeaderProtectionAction(e);if(n)if(console.log(`[AI DEBUG] Leader protection needed! Type: ${n.type}, Priority: ${n.priority}`),"move_leader"===n.type){const o=`move-${n.fromRow}-${n.fromCol}-${n.toRow}-${n.toCol}`;if(lastAIAction!==o)return updateAIThinking("Moving leader to safety!",6),console.log(`AI Player ${e} moving leader to safety: (${n.fromRow},${n.fromCol}) -> (${n.toRow},${n.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(n.fromRow,n.fromCol,n.toRow,n.toCol),stopAIThinking(),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}else if("attack_threat"===n.type){const o=`attack-${n.fromRow}-${n.fromCol}-${n.toRow}-${n.toCol}`;if(lastAIAction!==o)return console.log(`AI Player ${e} attacking threat to leader: (${n.fromRow},${n.fromCol}) -> (${n.toRow},${n.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),attack(n.fromRow,n.fromCol,n.toRow,n.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}else if("combined_attack_threat"===n.type){const o=`combined-attack-${n.target.row}-${n.target.col}`;if(lastAIAction!==o)return updateAIThinking("Combined attack to protect leader!",6),console.log(`AI Player ${e} using combined attack to eliminate leader threat at (${n.target.row},${n.target.col})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),performAICombinedAttack(n.attackers,n.target.row,n.target.col),stopAIThinking(),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}else if("block_for_leader"===n.type){const o=`move-${n.fromRow}-${n.fromCol}-${n.toRow}-${n.toCol}`;if(lastAIAction!==o)return console.log(`AI Player ${e} moving card to block for leader: (${n.fromRow},${n.fromCol}) -> (${n.toRow},${n.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(n.fromRow,n.fromCol,n.toRow,n.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}else if("eliminate_nearby_threat"===n.type){const o=`eliminate-nearby-${n.fromRow}-${n.fromCol}-${n.toRow}-${n.toCol}`;if(lastAIAction!==o)return updateAIThinking("Eliminating nearby threat to leader!",6),console.log(`AI Player ${e} eliminating nearby threat to leader: (${n.fromRow},${n.fromCol}) -> (${n.toRow},${n.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),attack(n.fromRow,n.fromCol,n.toRow,n.toCol),stopAIThinking(),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}else if("prevent_future_threat"===n.type){const o=`prevent-future-${n.fromRow}-${n.fromCol}-${n.toRow}-${n.toCol}`;if(lastAIAction!==o)return updateAIThinking("Preventing future threat to leader!",6),console.log(`AI Player ${e} preventing future threat to leader: (${n.fromRow},${n.fromCol}) -> (${n.toRow},${n.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),attack(n.fromRow,n.fromCol,n.toRow,n.toCol),stopAIThinking(),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}if(shouldRandomizeStrategy()&&(console.log(`[AI DEBUG] Player ${e} using randomized strategy this turn (${Math.floor(10)}% chance)`),Math.random()<.3)){console.log("[AI DEBUG] Random strategy: Skipping summon to prioritize attacks");const n=findBestCombinedAttack(e,o,r),s=findBestAttackAction(e,o,r);if(n&&s){if(Math.random()<.6){const o=`combined-attack-${n.target.row}-${n.target.col}-${n.combSize}`;if(lastAIAction!==o)return console.log(`AI Player ${e} random combined attack: ${n.combSize} cards attacking ${n.target.card.value}${n.target.card.suit}`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),performAICombinedAttack(n.attackers,n.target.row,n.target.col),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}else{const o=`attack-${s.fromRow}-${s.fromCol}-${s.toRow}-${s.toCol}`;if(lastAIAction!==o)return console.log(`AI Player ${e} random single attack: ${s.card.value}${s.card.suit}`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),attack(s.fromRow,s.fromCol,s.toRow,s.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}}}updateAIThinking("Evaluating summon options...",2);const s=findBestSummonAction(e);if(s){const o=`summon-${s.row}-${s.col}-${s.card.value}${s.card.suit}`;if(lastAIAction===o)return console.log(`AI Player ${e} detected repeated summon action, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300);updateAIThinking(`Summoning ${s.card.value}${s.card.suit}!`,6),console.log(`AI Player ${e} summoning ${s.card.value}${s.card.suit} to (${s.row},${s.col})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory();return placeCard(s.card,s.row,s.col)&&(gameState.leaderAttackedThisTurn=!0),stopAIThinking(),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}updateAIThinking("Checking defensive needs...",3);const l=findEmergencyDefenseAction(e);if(l){const o=`defense-${l.fromRow}-${l.fromCol}-${l.toRow}-${l.toCol}`;return lastAIAction===o?(console.log(`AI Player ${e} detected repeated defense action, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300)):(console.log(`AI Player ${e} EMERGENCY: moving ${l.card.value}${l.card.suit} to safety from (${l.fromRow},${l.fromCol}) to (${l.toRow},${l.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(l.fromRow,l.fromCol,l.toRow,l.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200))}updateAIThinking("Checking protective positioning...",3);const d=findProtectiveMovement(e);if(d){const o=`protect-move-${d.fromRow}-${d.fromCol}-${d.toRow}-${d.toCol}`;return lastAIAction===o?(console.log(`AI Player ${e} detected repeated protective move, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300)):(console.log(`AI Player ${e} protective movement (${d.type}): ${d.card.value}${d.card.suit} from (${d.fromRow},${d.fromCol}) to (${d.toRow},${d.toCol}) - threat level ${d.threatLevel}`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(d.fromRow,d.fromCol,d.toRow,d.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200))}updateAIThinking("Considering card replacements...",4);const i=findBestCardReplacement(e);if(i){const o=`replace-${i.row}-${i.col}-${i.newCard.value}${i.newCard.suit}`;if(lastAIAction===o)return console.log(`AI Player ${e} detected repeated replace action, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300);console.log(`AI Player ${e} replacing ${i.oldCard.value}${i.oldCard.suit} with ${i.newCard.value}${i.newCard.suit} at (${i.row},${i.col})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory();return replaceCard(i.row,i.col,i.newCard)&&(gameState.leaderAttackedThisTurn=!0),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}updateAIThinking("Planning combined attacks...",5);const c=findBestCombinedAttack(e,o,r);if(c){const o=`combined-attack-${c.target.row}-${c.target.col}-${c.combSize}`;if(lastAIAction!==o){const r=c.target.card.faceDown?" [FEARLESS FACE-DOWN ASSAULT]":"";return c.target.card.faceDown?updateAIThinking("Fearless assault on face-down threat!",6):updateAIThinking(`Combined attack: ${c.combSize} cards!`,6),console.log(`AI Player ${e} combined attack: ${c.combSize} cards attacking ${c.target.card.value}${c.target.card.suit} at (${c.target.row},${c.target.col}) - Total attack: ${c.totalAttack} vs ${c.targetDefense}${r}`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),performAICombinedAttack(c.attackers,c.target.row,c.target.col),stopAIThinking(),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}}const u=findBestAttackAction(e,o,r);if(u){const o=`attack-${u.fromRow}-${u.fromCol}-${u.toRow}-${u.toCol}`;if(lastAIAction===o)return console.log(`AI Player ${e} detected repeated action, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300);const r=gameState.board[u.toRow][u.toCol],n=u.expectedCapture?" [CAPTURE]":" [DAMAGE]",s=r?.faceDown?" [REVEAL FACE-DOWN]":"",l=u.isFaceDownOverride?" [FEARLESS OVERRIDE]":"",d=u.card.faceDown?" [FACE-DOWN ATTACKER]":"";return r?.faceDown?updateAIThinking("Fearlessly attacking face-down threat!",6):u.card.faceDown&&updateAIThinking("Using face-down card to attack!",6),console.log(`AI Player ${e} attacking with ${u.card.value}${u.card.suit} at (${u.fromRow},${u.fromCol}) -> (${u.toRow},${u.toCol})${n}${s}${l}${d}`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),attack(u.fromRow,u.fromCol,u.toRow,u.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}const g=findFrontLineFormationMove(e);if(g){const o=`front-line-${g.type}-${g.fromRow}-${g.fromCol}-${g.toRow}-${g.toCol}`;return lastAIAction===o?(console.log(`AI Player ${e} detected repeated front-line formation move, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300)):(console.log(`AI Player ${e} front-line formation (${g.type}): ${g.card.value}${g.card.suit} from (${g.fromRow},${g.fromCol}) to (${g.toRow},${g.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(g.fromRow,g.fromCol,g.toRow,g.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200))}const m=findDiamondFlankingMove(e);if(m){const o=`diamond-flank-${m.fromRow}-${m.fromCol}-${m.toRow}-${m.toCol}`;return lastAIAction===o?(console.log(`AI Player ${e} detected repeated diamond flanking move, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300)):(console.log(`AI Player ${e} diamond flanking maneuver: ${m.card.value}${m.card.suit} from (${m.fromRow},${m.fromCol}) to (${m.toRow},${m.toCol}) - targeting enemy formation`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(m.fromRow,m.fromCol,m.toRow,m.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200))}const f=findAggressiveLeaderMove(e);if(f){const o=`leader-move-${f.fromRow}-${f.fromCol}-${f.toRow}-${f.toCol}`;return lastAIAction===o?(console.log(`AI Player ${e} detected repeated leader move, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300)):(console.log(`AI Player ${e} moving leader aggressively from (${f.fromRow},${f.fromCol}) to (${f.toRow},${f.toCol}) for attack`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(f.fromRow,f.fromCol,f.toRow,f.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200))}const h=findStrategicMoveAction(e);if(h){const o=`move-${h.fromRow}-${h.fromCol}-${h.toRow}-${h.toCol}`;return lastAIAction===o?(console.log(`AI Player ${e} detected repeated strategic move, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300)):(console.log(`AI Player ${e} strategically moving ${h.card.value}${h.card.suit} from (${h.fromRow},${h.fromCol}) to (${h.toRow},${h.toCol}) for attack setup`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(h.fromRow,h.fromCol,h.toRow,h.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200))}const p=findBestMoveAction(e);if(p){const o=`move-${p.fromRow}-${p.fromCol}-${p.toRow}-${p.toCol}`;return lastAIAction===o?(console.log(`AI Player ${e} detected repeated move action, ending turn to prevent loop`),aiActionCount.delete(t),aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),void setTimeout(()=>endTurn(),300)):(console.log(`AI Player ${e} moving ${p.card.value}${p.card.suit} from (${p.fromRow},${p.fromCol}) to (${p.toRow},${p.toCol})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(p.fromRow,p.fromCol,p.toRow,p.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200))}updateAIThinking("Searching for fallback actions...",5),console.log("[AI DEBUG] No primary actions found, attempting fallback actions...");const S=findFallbackSummonAction(e);if(S){const o=`fallback-summon-${S.row}-${S.col}-${S.card.value}${S.card.suit}`;if(lastAIAction!==o){updateAIThinking(`Fallback: Summoning ${S.card.value}${S.card.suit}`,6),console.log(`AI Player ${e} fallback summon: ${S.card.value}${S.card.suit} to (${S.row},${S.col})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory();return placeCard(S.card,S.row,S.col)&&(gameState.leaderAttackedThisTurn=!0),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}}const v=findFallbackReplaceAction(e);if(v){const o=`fallback-replace-${v.row}-${v.col}-${v.newCard.value}${v.newCard.suit}`;if(lastAIAction!==o){console.log(`AI Player ${e} fallback replace: ${v.oldCard.value}${v.oldCard.suit} with ${v.newCard.value}${v.newCard.suit} at (${v.row},${v.col})`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory();return replaceCard(v.row,v.col,v.newCard)&&(gameState.leaderAttackedThisTurn=!0),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}}const C=findFallbackRepositionAction(e);if(C){const o=`fallback-reposition-${C.fromRow}-${C.fromCol}-${C.toRow}-${C.toCol}`;if(lastAIAction!==o)return console.log(`AI Player ${e} fallback reposition: ${C.card.value}${C.card.suit} from (${C.fromRow},${C.fromCol}) to (${C.toRow},${C.toCol}) for better formation`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(C.fromRow,C.fromCol,C.toRow,C.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}const y=findAnyLegalAction(e);if(y){console.log(`AI Player ${e} desperate action: ${y.type}`);const o=`desperate-${y.type}-${Math.random()}`;return lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),"move"===y.type?moveCard(y.fromRow,y.fromCol,y.toRow,y.toCol):"attack"===y.type&&attack(y.fromRow,y.fromCol,y.toRow,y.toCol),stopAIThinking(),updateUI(),void setTimeout(()=>performAITurnSequence(e),200)}const b=findForceMovementAction(e);if(b){const o=`force-move-${b.fromRow}-${b.fromCol}-${b.toRow}-${b.toCol}`;return console.log(`AI Player ${e} FORCE MOVEMENT: ${b.card.value}${b.card.suit} from (${b.fromRow},${b.fromCol}) to (${b.toRow},${b.toCol}) - ensuring cards move around`),lastAIAction=o,aiActionCount.set(t,a+1),saveStateToHistory(),moveCard(b.fromRow,b.fromCol,b.toRow,b.toCol),updateUI(),void setTimeout(()=>performAITurnSequence(e),100)}updateAIThinking("No actions available, ending turn",6),console.log(`AI Player ${e} ending turn after ${a} actions - truly no more moves available`),console.log(`[AI DEBUG] Final turn summary for player ${e}:`),console.log(`[AI DEBUG] - Actions this turn: ${a}`),console.log(`[AI DEBUG] - Cards moved this turn: ${gameState.cardsMovedThisTurn.size}`),console.log("[AI DEBUG] - Moved card IDs:",Array.from(gameState.cardsMovedThisTurn));let k=0;for(let t=0;t<11;t++)for(let a=0;a<11;a++){const o=gameState.board[t][a];o&&o.owner===e&&k++}console.log(`[AI DEBUG] - Total cards on board: ${k}`),aiActionCount.delete(t),lastAIAction=null,aiTurnTimeout&&(clearTimeout(aiTurnTimeout),aiTurnTimeout=null),stopAIThinking(),setTimeout(()=>endTurn(),300)}function findForceMovementAction(e){console.log(`[AI DEBUG] Finding force movement action for player ${e}`);const t=[];for(let a=0;a<11;a++)for(let o=0;o<11;o++){const r=gameState.board[a][o];r&&r.owner===e&&!gameState.cardsMovedThisTurn.has(r.id)&&t.push({card:r,row:a,col:o})}if(console.log(`[AI DEBUG] Found ${t.length} unmoved cards for force movement`),console.log("[AI DEBUG] Cards moved this turn:",Array.from(gameState.cardsMovedThisTurn)),0===t.length)return console.log("[AI DEBUG] No unmoved cards found - all cards have been moved this turn"),null;for(const{card:a,row:o,col:r}of t){console.log(`[AI DEBUG] Checking movement for ${a.value}${a.suit} at [${o},${r}]`);const t=getValidMoves(a,o,r);if(console.log(`[AI DEBUG] Valid moves found: ${t.length}`),0===t.length){console.log(`[AI DEBUG] No valid moves for ${a.value}${a.suit} at [${o},${r}]`);continue}let n=null,s=-999;for(const[l,d]of t){let t=1;if("diamonds"===a.suit){const a=findLeaderPosition(e);if(a){const e=Math.abs(o-a[0])+Math.abs(r-a[1]);Math.abs(l-a[0])+Math.abs(d-a[1])>e&&(t+=2)}}else{const a=findLeaderPosition(e);if(a){const e=Math.abs(o-a[0])+Math.abs(r-a[1]);Math.abs(l-a[0])+Math.abs(d-a[1])<e&&(t+=2)}}const i=1===e?2:1;(1===i&&l<o||2===i&&l>o)&&(t+=1),t>s&&(s=t,n=[l,d])}if(n)return console.log(`[AI DEBUG] Force movement for ${a.value}${a.suit}: [${o},${r}] to [${n[0]},${n[1]}] (score: ${s})`),{card:a,fromRow:o,fromCol:r,toRow:n[0],toCol:n[1]}}console.log("[AI DEBUG] No unmoved cards could move - trying emergency fallback with ANY card");for(let t=0;t<11;t++)for(let a=0;a<11;a++){const o=gameState.board[t][a];if(o&&o.owner===e){console.log(`[AI DEBUG] Emergency check: ${o.value}${o.suit} at [${t},${a}]`);const e=getValidMoves(o,t,a);if(e.length>0){const r=e[Math.floor(Math.random()*e.length)];return console.log(`[AI DEBUG] EMERGENCY MOVEMENT: ${o.value}${o.suit} from [${t},${a}] to [${r[0]},${r[1]}]`),{card:o,fromRow:t,fromCol:a,toRow:r[0],toCol:r[1]}}}}return console.log("[AI DEBUG] Absolutely no cards can move - this should be very rare"),null}function findBestAttackAction(e,t=!1,a=!1){const o=[];for(let t=0;t<11;t++)for(let a=0;a<11;a++){const r=gameState.board[t][a];r&&r.owner===e&&!isCardExhausted(r)&&r.attack>0&&o.push({card:r,row:t,col:a})}let r=null,n=-1;for(const{card:s,row:l,col:d}of o){const o=getValidAttacks(s,l,d);for(const[i,c]of o){const o=gameState.board[i][c];if(o&&o.owner!==e){let u=0;const g=s.attack>=o.defense;if(g){let e=100;t&&a&&(e+=200),o.faceDown&&(e+=150,console.log("[AI DEBUG] Face-down card attack bonus: +150 for revealing unknown threat")),u+=e;u+=10*(o.attack+o.defense),"joker"===o.suit&&(u+=500),o.attack>=4&&(u+=15*o.attack)}else{u+=5*Math.min(s.attack,o.defense),o.faceDown&&(u+=75,console.log("[AI DEBUG] Face-down reveal bonus: +75 for attacking to reveal unknown card"))}const m=findThreatsToCard(s,l,d,e);m.length>0&&m.some(e=>e.row===i&&e.col===c)&&(u+=80);const f=getAllEnemyCards(e);for(const e of f){if(e.row===i&&e.col===c)continue;if(Math.abs(i-e.row)+Math.abs(c-e.col)<=2){s.attack>=e.card.defense&&(u+=30)}}!willCardBeThreatenedAtPosition(s,i,c,e)?u+=20:o.faceDown&&(u+=10,console.log("[AI DEBUG] Fearless face-down attack: accepting risk to reveal unknown threat")),shouldRandomizeStrategy()&&(u=addRandomNoise(u,75)),u>n&&(n=u,r={card:s,fromRow:l,fromCol:d,toRow:i,toCol:c,expectedCapture:g,targetValue:o.attack+o.defense})}}}if(r&&!r.target?.faceDown)for(let t=0;t<11;t++)for(let a=0;a<11;a++){const o=gameState.board[t][a];if(o&&o.owner===e&&!isCardExhausted(o)&&o.attack>0){const r=getValidAttacks(o,t,a);for(const[s,l]of r){const r=gameState.board[s][l];if(r&&r.owner!==e&&r.faceDown&&o.attack>=r.defense&&n<300)return console.log("[AI DEBUG] FEARLESS OVERRIDE: Prioritizing face-down capture over lower-scoring face-up attack"),{card:o,fromRow:t,fromCol:a,toRow:s,toCol:l,expectedCapture:!0,targetValue:r.attack+r.defense,isFaceDownOverride:!0}}}}return r}function findBestCombinedAttack(e,t=!1,a=!1){const o=[];for(let t=0;t<11;t++)for(let a=0;a<11;a++){const r=gameState.board[t][a];r&&r.owner===e&&!isCardExhausted(r)&&r.attack>0&&o.push({card:r,row:t,col:a})}if(o.length<2)return null;const r=1===e?2:1,n=[];for(let e=0;e<11;e++)for(let t=0;t<11;t++){const a=gameState.board[e][t];a&&a.owner===r&&n.push({card:a,row:e,col:t})}let s=null,l=-1;for(let r=2;r<=Math.min(o.length,4);r++){const d=getCombinations(o,r);for(const o of d)for(const d of n){if(!o.every(e=>getValidAttacks(e.card,e.row,e.col).some(([e,t])=>e===d.row&&t===d.col)))continue;let n=0;for(const e of o)n+=e.card.attack;if(n>=d.card.defense){let i=0;const c=o.every(e=>e.card.attack<d.card.defense);c&&(i+=300),d.card.faceDown&&(i+=400,console.log(`[AI DEBUG] Face-down combined attack bonus: +400 for revealing unknown threat with ${r} cards`),c&&(i+=200,console.log("[AI DEBUG] Face-down coordinated assault bonus: +200 for multi-card reveal")));const u=d.card.attack+d.card.defense;i+=15*u,"joker"===d.card.suit&&(i+=800),d.card.defense>=5&&(i+=20*d.card.defense),t&&a&&(i+=400),i-=10*(r-2);let g=0;for(const t of o){if(!willCardBeThreatenedAtPosition(t.card,d.row,d.col,e))g+=10;else{g+=d.card.faceDown?-5:-20,d.card.faceDown&&console.log("[AI DEBUG] Fearless combined attack: reduced safety penalty for face-down target")}}i+=g,shouldRandomizeStrategy()&&(i=addRandomNoise(i,100)),i>l&&(l=i,s={attackers:o,target:d,totalAttack:n,targetDefense:d.card.defense,expectedCapture:!0,targetValue:u,combSize:r})}}}return s}function getCombinations(e,t){if(1===t)return e.map(e=>[e]);if(t>e.length)return[];const a=[];for(let o=0;o<=e.length-t;o++){const r=e[o],n=getCombinations(e.slice(o+1),t-1);for(const e of n)a.push([r,...e])}return a}function performAICombinedAttack(e,t,a){console.log(`[AI DEBUG] Executing combined attack with ${e.length} cards on target at [${t},${a}]`),gameState.selectedCards=[],gameState.selectedCard=null,gameState.validMoves=[],gameState.validAttacks=[],gameState.selectedHex=null;for(const t of e)console.log(`[AI DEBUG] Adding attacker: ${t.card.value}${t.card.suit} at [${t.row},${t.col}]`),gameState.selectedCards.push({card:t.card,position:[t.row,t.col]});console.log(`[AI DEBUG] Multi-selection state set up with ${gameState.selectedCards.length} cards`);const o=gameState.board[t][a];if(o){console.log(`[AI DEBUG] Combined attack target: ${o.value}${o.suit} (Defense: ${o.defense})`);try{performCombinedAttack(t,a),console.log("[AI DEBUG] Combined attack executed successfully")}catch(e){console.error("[AI DEBUG] Error during combined attack execution:",e)}}else console.log(`[AI DEBUG] Combined attack failed - target no longer exists at [${t},${a}]`);console.log("[AI DEBUG] Clearing selections after combined attack..."),gameState.selectedCards=[],gameState.selectedCard=null,gameState.validMoves=[],gameState.validAttacks=[],gameState.selectedHex=null,gameState.blockedMoves=[],gameState.absorptions=[],console.log("[AI DEBUG] Combined attack cleanup completed - all selections cleared")}function findBestLeaderProtectionAction(e){const t=findLeaderPosition(e);if(!t)return null;const[a,o]=t,r=gameState.board[a][o],n=findThreatsToCard(r,a,o,e).filter(e=>e.canCapture),s=[],l=[],d=1===e?2:1;for(let e=0;e<11;e++)for(let t=0;t<11;t++){const n=gameState.board[e][t];if(n&&n.owner===d&&!isCardExhausted(n)){const d=Math.abs(e-a)+Math.abs(t-o);if(d<=3&&n.attack>0&&l.push({card:n,row:e,col:t,distance:d,canCapture:n.attack>=r.defense}),d<=4&&n.attack>0){const l=getValidMoves(n,e,t);for(const[d,i]of l){if(Math.abs(d-a)+Math.abs(i-o)<=2){getValidAttacks(n,d,i).some(([e,t])=>e===a&&t===o)&&s.push({card:n,currentRow:e,currentCol:t,threatRow:d,threatCol:i,canCaptureAfterMove:n.attack>=r.defense})}}}}}const i=l.filter(e=>e.canCapture||e.distance<=2),c=s.filter(e=>e.canCaptureAfterMove);console.log(`[AI DEBUG] ULTRA-PROTECTIVE Leader Analysis:\n        - Immediate threats: ${n.length}\n        - Nearby dangerous enemies: ${i.length}\n        - Future threats (1-2 moves): ${c.length}\n        - Total danger level: ${n.length+i.length+c.length}`);if(0===n.length+i.length+c.length)return null;let u=null,g=-1;const m=getValidMoves(r,a,o);for(const[t,s]of m){if(!willCardBeThreatenedAtPosition(r,t,s,e)){let l=500;n.length>0&&(l+=1e3),c.length>0&&(l+=300);let d=0;for(const e of i){const a=Math.abs(t-e.row)+Math.abs(s-e.col);a>e.distance&&(d+=50*(a-e.distance))}l+=d;let m=0;for(let a=0;a<11;a++)for(let o=0;o<11;o++){const l=gameState.board[a][o];if(l&&l.owner===e&&l!==r){const r=Math.abs(t-a)+Math.abs(s-o);let d=!1;for(const e of[...n,...c,...i]){const n=e.row||e.currentRow,l=e.col||e.currentCol;if(Math.abs(a-n)+Math.abs(o-l)+r<=Math.abs(t-n)+Math.abs(s-l)+1){d=!0;break}}d?m+=200:1===r?m+=80:2===r&&(m+=40),r<=2&&l.attack>=5&&(m+=60);(1===e&&t<a||2===e&&t>a)&&r<=2&&(m+=150)}}l+=m;l+=30*(10-(1===e?t:10-t));l+=5*(10-(Math.abs(t-5)+Math.abs(s-5))),shouldRandomizeStrategy()&&(l=addRandomNoise(l,15)),l>g&&(g=l,u={type:"move_leader",fromRow:a,fromCol:o,toRow:t,toCol:s,priority:"leader_safety"})}}for(const t of n){const a=[];for(let o=0;o<11;o++)for(let r=0;r<11;r++){const n=gameState.board[o][r];if(n&&n.owner===e&&!isCardExhausted(n)&&n.attack>0){getValidAttacks(n,o,r).some(([e,a])=>e===t.row&&a===t.col)&&a.push({card:n,row:o,col:r})}}for(const e of a){if(e.card.attack>=t.card.defense){let a=800;a+=50*t.card.attack,t.canCapture&&(a+=1200),t.card.attack>=7?a+=400:t.card.attack>=5&&(a+=200),a>g&&(g=a,u={type:"attack_threat",fromRow:e.row,fromCol:e.col,toRow:t.row,toCol:t.col,priority:"eliminate_threat"})}}if(a.every(e=>e.card.attack<t.card.defense)&&a.length>=2)for(let e=0;e<a.length-1;e++)for(let o=e+1;o<a.length;o++){const r=a[e],n=a[o];if(r.card.attack+n.card.attack>=t.card.defense){let e=900;e+=75*t.card.attack,t.canCapture&&(e+=1500),t.card.attack>=8?e+=600:t.card.attack>=6&&(e+=300),e>g&&(g=e,u={type:"combined_attack_threat",attackers:[r,n],target:t,priority:"coordinate_defense"})}}}const f=getHexNeighbors(a,o);for(const[t,s]of f)if(!gameState.board[t][s])for(let l=0;l<11;l++)for(let d=0;d<11;d++){const i=gameState.board[l][d];if(i&&i.owner===e&&i!==r){if(getValidMoves(i,l,d).some(([e,a])=>e===t&&a===s)){let e=0;for(const t of n){!getValidAttacks(t.card,t.row,t.col).some(([e,t])=>e===a&&t===o)&&e++}if(e>0){let a=80+20*e;a>g&&(g=a,u={type:"block_for_leader",fromRow:l,fromCol:d,toRow:t,toCol:s,priority:"interposition"})}}}}for(const t of i){const a=[];for(let o=0;o<11;o++)for(let r=0;r<11;r++){const n=gameState.board[o][r];if(n&&n.owner===e&&!isCardExhausted(n)&&n.attack>0){getValidAttacks(n,o,r).some(([e,a])=>e===t.row&&a===t.col)&&a.push({card:n,row:o,col:r})}}for(const e of a){if(e.card.attack>=t.card.defense){let a=400;a+=30*t.card.attack,a+=100*(4-t.distance),t.canCapture&&(a+=800),a>g&&(g=a,u={type:"eliminate_nearby_threat",fromRow:e.row,fromCol:e.col,toRow:t.row,toCol:t.col,priority:"proactive_defense"})}}}for(const t of c){const a=[];for(let o=0;o<11;o++)for(let r=0;r<11;r++){const n=gameState.board[o][r];if(n&&n.owner===e&&!isCardExhausted(n)&&n.attack>0){getValidAttacks(n,o,r).some(([e,a])=>e===t.currentRow&&a===t.currentCol)&&a.push({card:n,row:o,col:r})}}for(const e of a){if(e.card.attack>=t.card.defense){let a=300;a+=25*t.card.attack,t.canCaptureAfterMove&&(a+=600),a>g&&(g=a,u={type:"prevent_future_threat",fromRow:e.row,fromCol:e.col,toRow:t.currentRow,toCol:t.currentCol,priority:"preventive_strike"})}}}return u}function findThreatsToCard(e,t,a,o){const r=[],n=1===o?2:1;for(let o=0;o<11;o++)for(let s=0;s<11;s++){const l=gameState.board[o][s];if(l&&l.owner===n&&!isCardExhausted(l)){const n=getValidAttacks(l,o,s);for(const[d,i]of n)d===t&&i===a&&(l.attack>=e.defense?r.push({card:l,row:o,col:s,canCapture:!0}):r.push({card:l,row:o,col:s,canCapture:!1}))}}return r}function getAllEnemyCards(e){const t=[],a=1===e?2:1;for(let e=0;e<11;e++)for(let o=0;o<11;o++){const r=gameState.board[e][o];r&&r.owner===a&&t.push({card:r,row:e,col:o})}return t}function willCardBeThreatenedAtPosition(e,t,a,o){const r=1===o?2:1;for(let o=0;o<11;o++)for(let n=0;n<11;n++){const s=gameState.board[o][n];if(s&&s.owner===r&&!isCardExhausted(s)){const r=getValidAttacks(s,o,n);for(const[o,n]of r)if(o===t&&n===a&&s.attack>=e.defense)return!0}}return!1}function findBestSummonAction(e){const t=findLeaderPosition(e);if(console.log(`[AI DEBUG] findBestSummonAction - Player ${e}, Leader at:`,t,`LeaderAttacked: ${gameState.leaderAttackedThisTurn}, Hand length: ${gameState.players[e].hand.length}`),!t||0===gameState.players[e].hand.length)return console.log(`[AI DEBUG] Cannot summon - no leader:${!t}, no hand:${0===gameState.players[e].hand.length}`),null;gameState.leaderAttackedThisTurn&&console.log("[AI DEBUG] Leader attacked this turn but STILL ATTEMPTING SUMMON (forced aggressive summoning)");let a=0;for(let t=0;t<11;t++)for(let o=0;o<11;o++){const r=gameState.board[t][o];r&&r.owner===e&&"joker"!==r.suit&&a++}if(console.log(`[AI DEBUG] Player ${e} has ${a} cards on map`),a<5)return console.log(`[AI DEBUG] CASE 1: Less than 5 cards (${a}) - summon best card available`),findBestCardToSummon(e,!0);console.log("[AI DEBUG] CASE 2: Have 5 cards - checking replacement opportunities");const o=findBestReplacementNextToLeader(e);return o?(console.log(`[AI DEBUG] Found replacement opportunity: ${o.newCard.value}${o.newCard.suit} replacing ${o.oldCard.value}${o.oldCard.suit}`),o):(console.log("[AI DEBUG] CASE 3: Have 5 cards and no better replacement found - skipping summoning to focus on movement/attacks"),null)}function findBestCardToSummon(e,t=!0){console.log(`[AI DEBUG] Finding best card to summon for player ${e}`);const a=findLeaderPosition(e);if(!a)return null;const o=gameState.players[e].hand;if(0===o.length)return null;const r=getHexNeighbors(a[0],a[1]).filter(([a,o])=>{const r=gameState.board[a][o];return(!r||r.owner===e)&&!(!t&&!r)});if(0===r.length)return null;let n=null,s=-1;for(const e of o){if("joker"===e.suit)continue;const t=2*(e.attack+e.defense)+3*getCardValuePriority(e);t>s&&(s=t,n=e)}if(!n)return null;let l=null,d=-1;for(const[t,a]of r){let o=50;const r=gameState.board[t][a];if(r){const e=n.attack+n.defense-(r.attack+r.defense);e<=0?o-=200:o+=10*e}else o+=100;const s=getValidAttacks(n,t,a);for(const[t,a]of s){const r=gameState.board[t][a];r&&r.owner!==e&&n.attack>=r.defense&&(o+=30,"joker"===r.suit&&(o+=100))}o>d&&(d=o,l=[t,a])}return l?(console.log(`[AI DEBUG] Best card to summon: ${n.value}${n.suit} to [${l[0]},${l[1]}] (score: ${d})`),{card:n,row:l[0],col:l[1]}):null}function findBestReplacementNextToLeader(e){console.log(`[AI DEBUG] Finding best replacement next to leader for player ${e}`);const t=findLeaderPosition(e);if(!t)return null;const a=gameState.players[e].hand;if(0===a.length)return null;const o=getHexNeighbors(t[0],t[1]).filter(([t,a])=>{const o=gameState.board[t][a];return o&&o.owner===e&&"joker"!==o.suit}).map(([e,t])=>({card:gameState.board[e][t],row:e,col:t}));if(0===o.length)return console.log("[AI DEBUG] No cards adjacent to leader for replacement"),null;let r=null,n=0;for(const e of a){if("joker"===e.suit)continue;const t=e.attack+e.defense;for(const{card:a,row:s,col:l}of o){const o=t-(a.attack+a.defense);o>=2&&o>n&&(n=o,r={newCard:e,oldCard:a,row:s,col:l,card:e})}}return r?console.log(`[AI DEBUG] Best replacement: ${r.newCard.value}${r.newCard.suit} (${r.newCard.attack+r.newCard.defense}) replacing ${r.oldCard.value}${r.oldCard.suit} (${r.oldCard.attack+r.oldCard.defense}) - upgrade: +${n}`):console.log("[AI DEBUG] No worthwhile replacements found (need at least +2 upgrade)"),r}function findBestCardReplacement(e){if("play"!==gameState.phase||0===gameState.players[e].hand.length)return null;if(card.attack>=target.defense&&(captureOpportunities++,captureValue+=target.attack+target.defense,"joker"===target.suit)){score+=300,score+=4*card.defense;const t=getCardValuePriority(card);score+=12*t,console.log(`[AI DEBUG] Card ${card.value}${card.suit} value priority: ${t} (bonus: +${12*t})`);const a=gameState.board[row][col];if(a&&a.owner===e){const e=card.attack+card.defense,t=a.attack+a.defense,o=e-t;mapCounts.totalCards<5&&(score-=300,console.log(`[AI DEBUG] Board expansion mode: HEAVY penalizing replacement (${mapCounts.totalCards} < 5 cards)`)),o<0?(score-=500,console.log(`[AI DEBUG] NEVER downgrade: blocking replacement of ${a.value}${a.suit} (${t}) with weaker ${card.value}${card.suit} (${e})`)):o>0?mapCounts.totalCards>=5&&o>=2?(score+=20*o,console.log(`[AI DEBUG] Meaningful upgrade allowed at max cards: +${o} total value`)):o<2&&(score-=50,console.log(`[AI DEBUG] Minor upgrade not worth it: only +${o} improvement`)):(score-=200,console.log("[AI DEBUG] Same-value replacement blocked: no improvement")),console.log(`[AI DEBUG] Replacement analysis at [${row},${col}]: ${card.value}${card.suit} (${e}) vs ${a.value}${a.suit} (${t}), upgrade: ${o}, totalCards: ${mapCounts.totalCards}`)}else mapCounts.totalCards<5?(score+=200,console.log(`[AI DEBUG] Board expansion mode: BIG bonus for empty position (${mapCounts.totalCards} < 5 cards)`)):score+=30;willCardBeThreatenedAtPosition(card,row,col,e)?score-=40:score+=20;let o=0;for(let t=0;t<11;t++)for(let a=0;a<11;a++){const r=gameState.board[t][a];if(r&&r.owner===e){if(Math.abs(row-t)+Math.abs(col-a)<=2){const n=findThreatsToCard(r,t,a,e);n.length>0&&(o+=15*n.length)}}}score+=o;let r=0;const n=getAllEnemyCards(e);for(const e of n){Math.abs(row-e.row)+Math.abs(col-e.col)<=3&&card.attack>=e.card.defense&&r++}score+=10*r;const s=getAggressionModifier(e);let l=0;if(n.length>0){let t=999,a=null;for(const e of n){const o=Math.abs(row-e.row)+Math.abs(col-e.col);o<t&&(t=o),"joker"===e.card.suit&&(a=e)}if(t<=3){l+=15*(4-t)*(s-.5)}if(a){const e=Math.abs(row-a.row)+Math.abs(col-a.col);if(e<=4){l+=20*(5-e)*(s-.5)}}console.log(`[AI DEBUG] Aggression bonus for ${card.value}${card.suit} at [${row},${col}]: +${Math.round(l)} (aggression: ${aiAggression[e]}, modifier: ${s.toFixed(2)})`)}score+=l;const d=findLeaderPosition(e);if(d){const[t,a]=d,o=calculateFrontLineBonus(e,d,row,col);score+=o,console.log(`[AI DEBUG] Front-line positioning bonus for ${card.value}${card.suit} at [${row},${col}]: +${o}`);const r=Math.abs(row-t)+Math.abs(col-a);if("diamonds"===card.suit){const t=findLeaderPosition(1===e?2:1);if(r>=5?score+=80:r>=3?score+=50:score-=40,t){const e=Math.abs(row-t[0])+Math.abs(col-t[1]);e<=2?score+=120:e<=4?score+=60:e<=6&&(score+=30),console.log(`[AI DEBUG] Diamond ${card.value}${card.suit} flanking enemy leader: distance to our leader=${r}, distance to enemy leader=${e}`)}const a=getHexNeighbors(row,col).filter(([t,a])=>{const o=gameState.board[t][a];return o&&o.owner===e}).length;0===a?score+=35:a>=2&&(score-=30),console.log(`[AI DEBUG] Diamond ${card.value}${card.suit} independent flanking: distance from our leader=${r}, ${a} neighbors`)}else{1===r?score+=100:2===r?score+=80:3===r?score+=60:r>=4&&(score-=50),isInFrontOfLeader(e,d,row,col)?(score+=70,r<=2&&(score+=50)):score-=20;const o=getAllEnemyCards(e);let n=0;for(const e of o){const o=Math.abs(e.row-t)+Math.abs(e.col-a);Math.abs(e.row-row)+Math.abs(e.col-col)+(Math.abs(row-t)+Math.abs(col-a))<=o+1&&(n+=30)}if(score+=n,o.length>0){const e=[Math.round(o.reduce((e,{row:t})=>e+t,0)/o.length),Math.round(o.reduce((e,{col:t})=>e+t,0)/o.length)],n=Math.abs(t-e[0])+Math.abs(a-e[1]);Math.abs(row-e[0])+Math.abs(col-e[1])<n&&r<=3&&(score+=25)}console.log(`[AI DEBUG] Protective formation bonus for ${card.value}${card.suit} at distance ${r} from leader, intercept bonus: +${n}`)}if(isInFrontOfLeader(e,d,row,col)){const t=getHexNeighbors(row,col).filter(([t,a])=>{const o=gameState.board[t][a];return o&&o.owner===e&&"joker"!==o.suit});if("diamonds"===card.suit)score+=15*t.length;else{score+=35*t.length;const e=t.filter(([e,t])=>"diamonds"!==gameState.board[e][t].suit).length;score+=25*e,console.log(`[AI DEBUG] Non-diamond formation bonus for ${card.value}${card.suit}: ${t.length} total neighbors, ${e} non-diamond neighbors`)}}}const i=calculateLeaderThreatVectors(e);let c=0;for(const e of i){const t=d[0],a=d[1],o=(e.enemyRow,e.enemyCol,row,e.enemyRow,col,e.enemyCol,Math.abs(e.enemyRow-t)+Math.abs(e.enemyCol-a));if(Math.abs(row-e.enemyRow)+Math.abs(col-e.enemyCol)+(Math.abs(row-t)+Math.abs(col-a))<=o+1){const t=e.canCurrentlyAttack?80:40;c+=t,console.log(`[AI DEBUG] Position [${row},${col}] blocks threat from [${e.enemyRow},${e.enemyCol}] - bonus: +${t}`)}}score+=c;const u=Math.abs(row-5)+Math.abs(col-5);score+=.3*(10-u);const g=gameState.board[row][col];if(g&&g.owner===e){const e=card.attack+card.defense,t=g.attack+g.defense;e>t&&(score+=3*(e-t))}shouldRandomizeStrategy()&&(score=addRandomNoise(score,60)),score>bestScore&&(bestScore=score,bestAction={card:card,row:row,col:col})}if(mustSummonDueToCardCount&&bestAction)return console.log(`[AI DEBUG] MANDATORY SUMMON due to card count (${mapCounts.regularCards} < 5) - forcing summoning with score ${bestScore}`),bestAction;if(bestAction&&bestScore>1)return bestAction;if(mustSummonDueToCardCount&&validSummonPositions.length>0&&hand.length>0){console.log(`[AI DEBUG] FORCED FALLBACK SUMMON due to card count (${mapCounts.regularCards} < 5) - summoning strongest available card`);const e=hand.reduce((e,t)=>{const a=e?e.attack+e.defense:0;return t.attack+t.defense>a?t:e},null);if(e)return{card:e,row:validSummonPositions[0][0],col:validSummonPositions[0][1]}}if(validSummonPositions.length>0&&hand.length>0){const e=hand.reduce((e,t)=>{const a=e?e.attack+e.defense:0;return t.attack+t.defense>a?t:e},null);if(e)return{card:e,row:validSummonPositions[0][0],col:validSummonPositions[0][1]}}return null}function findBestCardReplacement(e){if("play"!==gameState.phase||0===gameState.players[e].hand.length)return null;if(gameState.leaderAttackedThisTurn)return console.log("[AI DEBUG] Cannot replace cards - leader already used this turn"),null;const t=findLeaderPosition(e);if(!t)return console.log("[AI DEBUG] Cannot replace cards - no leader on board"),null;const[a,o]=t,r=getHexNeighbors(a,o),n=[];for(const[t,a]of r){const o=gameState.board[t][a];o&&o.owner===e&&n.push({card:o,row:t,col:a})}if(console.log(`[AI DEBUG] Found ${n.length} cards adjacent to leader for potential replacement`),0===n.length)return null;const s=countCardsOnMap(e);s.regularCards<5&&console.log(`[AI DEBUG] Board expansion mode (${s.regularCards} < 5 cards): being very conservative about replacements`);const l=gameState.players[e].hand;let d=null,i=-1;for(const t of l)for(const{card:a,row:o,col:r}of n){if("joker"===a.suit&&"joker"!==t.suit)continue;const n=t.attack+t.defense-(a.attack+a.defense);if(n<=0)continue;let l=8*n;const c=getCardValuePriority(t),u=getCardValuePriority(a),g=c-u;l+=8*g,console.log(`[AI DEBUG] Replacement value priority: ${t.value}${t.suit} (${c}) vs ${a.value}${a.suit} (${u}), diff: ${g}`),s<5&&(l-=80,console.log(`[AI DEBUG] Board expansion penalty applied: -80 to replacement score (${s} < 5 cards)`));const m=getValidAttacks(t,o,r);let f=0,h=0;for(const[a,o]of m){const r=gameState.board[a][o];r&&r.owner!==e&&t.attack>=r.defense&&(f++,h+=r.attack+r.defense,"joker"===r.suit&&(l+=250))}l+=40*f,l+=6*h,t.attack>a.attack&&(l+=10*(t.attack-a.attack)),t.defense>a.defense&&(l+=8*(t.defense-a.defense));const p=findThreatsToCard(a,o,r,e),S=findThreatsToCard(t,o,r,e),v=p.filter(e=>e.canCapture).length,C=S.filter(e=>e.canCapture).length;C<v&&(l+=30*(v-C));let y=0;const b=getAllEnemyCards(e);for(const e of b){Math.abs(o-e.row)+Math.abs(r-e.col)<=2&&(y+=15,t.attack>=e.card.defense&&(y+=20))}l+=y,l>i&&(i=l,d={oldCard:a,newCard:t,row:o,col:r})}const c=s<5?100:5;return console.log(`[AI DEBUG] Replacement threshold: ${c} (${s} cards on board), best score: ${i}`),d&&i>c?d:null}function findEmergencyDefenseAction(e){const t=[];for(let a=0;a<11;a++)for(let o=0;o<11;o++){const r=gameState.board[a][o];r&&r.owner===e&&!isCardExhausted(r)&&t.push({card:r,row:a,col:o})}let a=null,o=-1;for(const{card:r,row:n,col:s}of t){const t=findThreatsToCard(r,n,s,e).filter(e=>e.canCapture);if(t.length>0){const l=getValidMoves(r,n,s);for(const[d,i]of l){const l=findThreatsToCard(r,d,i,e).filter(e=>e.canCapture);if(l.length<t.length){let e=50*(t.length-l.length);e+=5*(r.attack+r.defense),"joker"===r.suit&&(e+=300),0===l.length&&(e+=30),e>o&&(o=e,a={card:r,fromRow:n,fromCol:s,toRow:d,toCol:i,threatsAvoided:t.length-l.length})}}}}return a&&o>40?a:null}function replaceCard(e,t,a){const o=gameState.board[e][t];return o&&o.owner===a.owner?placeCard(a,e,t):(console.log("Cannot replace card: invalid position or ownership"),!1)}function findAggressiveLeaderMove(e){const t=findLeaderPosition(e);if(!t)return null;const[a,o]=t,r=gameState.board[a][o];if(isCardExhausted(r))return null;const n=getValidMoves(r,a,o);if(0===n.length)return null;let s=null,l=-1;for(const[t,d]of n){let n=0;const i=getValidAttacks(r,t,d);let c=0,u=0;for(const[t,a]of i){const o=gameState.board[t][a];o&&o.owner!==e&&r.attack>=o.defense&&(c++,u+=o.attack+o.defense,"joker"===o.suit?n+=400:n+=60)}n+=80*c,n+=5*u;if(willCardBeThreatenedAtPosition(r,t,d,e)){findThreatsToCard(r,t,d,e).filter(e=>e.canCapture).length>0?n-=200:n-=50}else n+=30;let g=0;for(let a=0;a<11;a++)for(let o=0;o<11;o++){const n=gameState.board[a][o];if(n&&n.owner!==e){const e=Math.abs(t-a)+Math.abs(d-o);let s=n.attack+n.defense;if("joker"===n.suit&&(s+=100),r.attack>=n.defense){const t=Math.max(0,10-e)*s*.1;g=Math.max(g,t)}}}n+=g;n+=.8*(10-(Math.abs(t-5)+Math.abs(d-5))),n>l&&(l=n,s={card:r,fromRow:a,fromCol:o,toRow:t,toCol:d})}return s&&l>8?s:null}function findStrategicMoveAction(e){const t=[];for(let a=0;a<11;a++)for(let o=0;o<11;o++){const r=gameState.board[a][o];r&&r.owner===e&&!isCardExhausted(r)&&"joker"!==r.suit&&t.push({card:r,row:a,col:o})}const a=findLeaderPosition(e),o=findLeaderPosition(1===e?2:1),r=t.filter(({card:e})=>"diamonds"!==e.suit),n=t.filter(({card:e})=>"diamonds"===e.suit);console.log(`[AI DEBUG] Strategic movement: ${r.length} non-diamonds (formation), ${n.length} diamonds (flanking)`);let s=null,l=-1;for(const{card:t,row:o,col:n}of r){const d=getValidMoves(t,o,n);if(0!==d.length)for(const[i,c]of d){let d=0;if(a){const r=Math.abs(i-a[0])+Math.abs(c-a[1]);1===r?d+=80:2===r?d+=60:3===r?d+=40:r>=4&&(d-=40),r<Math.abs(o-a[0])+Math.abs(n-a[1])&&(d+=30),isInFrontOfLeader(e,a,i,c)&&(d+=70,r<=2&&(d+=40)),console.log(`[AI DEBUG] Leader protection movement for ${t.value}${t.suit}: distance to leader=${r}`)}let u=0,g=0;for(const{card:e,row:a,col:o}of r){if(e===t)continue;const r=Math.abs(i-a)+Math.abs(c-o);r<=2&&(u+=20*(3-r),g++)}d+=u;const m=getAllEnemyCards(e);let f=0;if(a)for(const e of m){const t=Math.abs(e.row-a[0])+Math.abs(e.col-a[1]);Math.abs(e.row-i)+Math.abs(e.col-c)+(Math.abs(i-a[0])+Math.abs(c-a[1]))<=t+1&&(f+=40)}d+=f;const h=getValidAttacks(t,i,c);for(const[a,o]of h){const n=gameState.board[a][o];if(n&&n.owner!==e){d+=12;let e=1;for(const{card:n,row:s,col:l}of r){if(n===t)continue;getValidAttacks(n,s,l).some(([e,t])=>e===a&&t===o)&&e++}e>1&&(d+=15*e)}}const p=getAggressionModifier(e);let S=0;if(m.length>0){let a=999,o=999;for(const e of m){const t=Math.abs(i-e.row)+Math.abs(c-e.col);t<a&&(a=t),"joker"===e.card.suit&&(o=t)}if(a<=4){S+=10*(5-a)*(p-.8)}if(o<=5){S+=15*(6-o)*(p-.8)}console.log(`[AI DEBUG] Non-diamond aggression bonus for ${t.value}${t.suit}: +${Math.round(S)} (aggression: ${aiAggression[e]})`)}d+=S,d+=2*t.attack+3*t.defense,d>l&&(l=d,s={card:t,fromRow:o,fromCol:n,toRow:i,toCol:c,moveType:"leader_protection"})}}for(const{card:t,row:d,col:i}of n){const n=getValidMoves(t,d,i);if(0!==n.length)for(const[c,u]of n){let n=0;if(a){const e=Math.abs(c-a[0])+Math.abs(u-a[1]);e>Math.abs(d-a[0])+Math.abs(i-a[1])&&(n+=40),e>=5?n+=60:e>=3?n+=30:n-=30}if(o){const e=Math.abs(c-o[0])+Math.abs(u-o[1]);e<Math.abs(d-o[0])+Math.abs(i-o[1])&&(n+=50),e<=2?n+=100:e<=4?n+=60:e<=6&&(n+=25),console.log(`[AI DEBUG] Diamond movement toward enemy leader: distance=${e}, bonus applied`)}const g=getValidAttacks(t,c,u);for(const[t,a]of g){const o=gameState.board[t][a];o&&o.owner!==e&&("joker"===o.suit?n+=150:n+=15)}const m=getAggressionModifier(e);let f=0;if(o){const a=Math.abs(c-o[0])+Math.abs(u-o[1]);if(a<=3){f+=25*(4-a)*m}a<Math.abs(d-o[0])+Math.abs(i-o[1])&&(f+=20*m),console.log(`[AI DEBUG] Diamond aggression bonus for ${t.value}${t.suit}: +${Math.round(f)} (aggression: ${aiAggression[e]})`)}n+=f;let h=30;for(const{row:e,col:t}of r){const a=Math.abs(c-e)+Math.abs(u-t);a<=1?h-=25:a<=2&&(h-=10)}n+=h,n*=1.1+.2*(m-1),n>l&&(l=n,s={card:t,fromRow:d,fromCol:i,toRow:c,toCol:u,moveType:"diamond_enemy_leader_flanking"})}}return s&&l>0?(console.log(`[AI DEBUG] Strategic move selected: ${s.card.value}${s.card.suit} (${s.moveType}) from [${s.fromRow},${s.fromCol}] to [${s.toRow},${s.toCol}] (score: ${l})`),s):null}function findBestMoveAction(e){const t=[];for(let a=0;a<11;a++)for(let o=0;o<11;o++){const r=gameState.board[a][o];r&&r.owner===e&&!isCardExhausted(r)&&t.push({card:r,row:a,col:o})}for(const{card:e,row:a,col:o}of t){const t=getValidMoves(e,a,o);if(t.length>0){let r=null,n=-1;for(const[a,o]of t){let t=getValidAttacks(e,a,o).length;t+=.1*(10-(Math.abs(a-5)+Math.abs(o-5))),t>n&&(n=t,r=[a,o])}if(r&&n>=0)return{card:e,fromRow:a,fromCol:o,toRow:r[0],toCol:r[1]}}}return null}function performAISetupMove(e){aiEnabled[e]&&gameState.currentPlayer===e&&"setup"===gameState.phase&&(isDraggingCard||gameState.selectedCard?setTimeout(()=>performAISetupMove(e),300):(console.log(`AI Player ${e} starting setup...`),performAISetupSequence(e)))}function performAISetupSequence(e){if(!aiEnabled[e]||gameState.currentPlayer!==e||"setup"!==gameState.phase)return;const t=gameState.players[e],a=gameState.setupLeaderPlaced[e],o=gameState.setupCardsPlaced[e];if(o>=6)console.log(`AI Player ${e} setup complete - already placed ${o} cards`);else{if(!a&&t.hand.some(e=>"joker"===e.suit)){const a=t.hand.find(e=>"joker"===e.suit),o=[],r=1===e?4:10;for(let t=1===e?0:6;t<=r;t++)for(let e=0;e<11;e++)isValidHex(t,e)&&!gameState.board[t][e]&&o.push([t,e]);if(o.length>0){let t;const r=getAggressionModifier(e),n=Math.random(),s=.7-.2*(r-1);if(n<.3+.4*(r-1)){const a=o.filter(([t,a])=>(1===e?4-t:t-6)<=2);if(a.length>0)t=a[Math.floor(Math.random()*a.length)],console.log(`AI Player ${e} placing leader AGGRESSIVELY FORWARD at (${t[0]},${t[1]}) (aggression: ${aiAggression[e]})`);else{const a=o.filter(([e,t])=>t<=2||t>=8);a.length>0?(t=a[Math.floor(Math.random()*a.length)],console.log(`AI Player ${e} placing leader AGGRESSIVELY at edge (${t[0]},${t[1]})`)):t=o[Math.floor(Math.random()*o.length)]}}else if(n<s){const a=o.filter(([e,t])=>t>=3&&t<=7);if(a.length>0){const o=a.filter(([t,a])=>(1===e?4-t:t-6)>=2);o.length>0&&r<1.2?(t=o[Math.floor(Math.random()*o.length)],console.log(`AI Player ${e} placing leader DEFENSIVELY in back-center (${t[0]},${t[1]}) (aggression: ${aiAggression[e]})`)):(t=a[Math.floor(Math.random()*a.length)],console.log(`AI Player ${e} placing leader DEFENSIVELY in center (${t[0]},${t[1]})`))}else t=o[Math.floor(Math.random()*o.length)]}else t=o[Math.floor(Math.random()*o.length)],console.log(`AI Player ${e} placing leader RANDOMLY at (${t[0]},${t[1]})`);return gameState.selectedCard=a,handleSetupClick(t[0],t[1]),void setTimeout(()=>performAISetupSequence(e),200)}}if(o<6&&t.hand.length>0){const a=t.hand.filter(e=>"joker"!==e.suit);if(a.length>0){let t;const o=Math.random();o<.4?(t=a[Math.floor(Math.random()*a.length)],console.log(`AI Player ${e} selecting RANDOM card: ${t.value}${t.suit}`)):o<.7?(t=a.reduce((e,t)=>!e||t.attack<e.attack?t:e,a[0]),console.log(`AI Player ${e} selecting WEAKEST card: ${t.value}${t.suit}`)):(t=a.reduce((e,t)=>!e||t.attack>e.attack?t:e,a[0]),console.log(`AI Player ${e} selecting STRONGEST card: ${t.value}${t.suit}`));const r=findLeaderPosition(e);let n=null;const s=Math.random(),l=getAggressionModifier(e),d=1===e?4:10,i=[];for(let t=1===e?0:6;t<=d;t++)for(let e=0;e<11;e++)isValidHex(t,e)&&!gameState.board[t][e]&&i.push([t,e]);if(i.length>0&&r){if("diamonds"===t.suit){const t=i.filter(([e,t])=>Math.abs(e-r[0])+Math.abs(t-r[1])>=4);t.length>0?(n=t[Math.floor(Math.random()*t.length)],console.log(`AI Player ${e} placing DIAMOND FAR from leader at (${n[0]},${n[1]}) for flanking`)):(n=i[Math.floor(Math.random()*i.length)],console.log(`AI Player ${e} placing DIAMOND (fallback) at (${n[0]},${n[1]})`))}else{if(s<.8-.3*(l-1)){const t=l>1.2?4:3,a=i.filter(([e,a])=>{const o=Math.abs(e-r[0])+Math.abs(a-r[1]);return o>=1&&o<=t});if(a.length>0){const t=a.filter(([t,a])=>isInFrontOfLeader(e,r,t,a)),o=.6+.3*(l-1);if(t.length>0&&Math.random()<o)if(l>1.3){n=t.sort(([t,a],[o,r])=>(1===e?o:10-o)-(1===e?t:10-t))[0],console.log(`AI Player ${e} placing NON-DIAMOND AGGRESSIVELY FORWARD at (${n[0]},${n[1]}) (aggression: ${aiAggression[e]})`)}else n=t[Math.floor(Math.random()*t.length)],console.log(`AI Player ${e} placing NON-DIAMOND in FRONT-PROTECTIVE position at (${n[0]},${n[1]})`);else n=a[Math.floor(Math.random()*a.length)],console.log(`AI Player ${e} placing NON-DIAMOND in PROTECTIVE position at (${n[0]},${n[1]})`)}}else{const t=getHexNeighbors(r[0],r[1]).filter(([e,t])=>isValidHex(e,t)&&!gameState.board[e][t]);t.length>0&&(n=t[Math.floor(Math.random()*t.length)],console.log(`AI Player ${e} placing NON-DIAMOND ADJACENT to leader at (${n[0]},${n[1]})`))}}if(!n)if(r)n=i[Math.floor(Math.random()*i.length)],console.log(`AI Player ${e} using RANDOM positioning at (${n[0]},${n[1]})`);else{const t=i.filter(([t,a])=>1===e?t>=2:t<=8);t.length>0&&(n=t[Math.floor(Math.random()*t.length)],console.log(`AI Player ${e} placing in FORWARD position (no leader yet) at (${n[0]},${n[1]})`))}return n||(n=i[Math.floor(Math.random()*i.length)],console.log(`AI Player ${e} using FALLBACK positioning at (${n[0]},${n[1]})`)),gameState.selectedCard=t,handleSetupClick(n[0],n[1]),void setTimeout(()=>performAISetupSequence(e),200)}}}console.log(`AI Player ${e} setup complete - placed ${o} cards`)}}let hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,mobileHoveredHex=null,isMobileHovering=!1,isMobileMultiSelectMode=!1;const isTouchDevice="ontouchstart"in window||navigator.maxTouchPoints>0;let validDiscards=[],dragState={isDragging:!1,dragType:null,draggedCard:null,startX:0,startY:0,startHex:null,currentHex:null,mapStartX:0,mapStartY:0,originalSelection:null},isDraggingCard=!1,isDraggingMap=!1,draggedCard=null,dragUpdateRequested=!1,lastMousePos=null;function saveGameState(){try{const e={...gameState,cardsMovedThisTurn:Array.from(gameState.cardsMovedThisTurn),cardsAttackedThisTurn:Array.from(gameState.cardsAttackedThisTurn),cardsAttackExhaustion:Object.fromEntries(gameState.cardsAttackExhaustion),mapRotated:mapRotated,mapFlippingEnabled:mapFlippingEnabled,aiEnabled:aiEnabled,zoomLevel:zoomLevel,boardOffsetX:boardOffsetX,boardOffsetY:boardOffsetY};localStorage.setItem("tcg-game-state",JSON.stringify(e))}catch(e){console.warn("Failed to save game state:",e)}}function loadGameState(){try{const e=localStorage.getItem("tcg-game-state");if(e){const t=JSON.parse(e);if(t.cardsMovedThisTurn=new Set(t.cardsMovedThisTurn||[]),t.cardsAttackedThisTurn=new Set(t.cardsAttackedThisTurn||[]),t.cardsAttackExhaustion=new Map(Object.entries(t.cardsAttackExhaustion||{})),void 0!==t.mapRotated&&(mapRotated=t.mapRotated),void 0!==t.mapFlippingEnabled&&(mapFlippingEnabled=t.mapFlippingEnabled),void 0!==t.zoomLevel&&(zoomLevel=t.zoomLevel,hexSize=baseHexSize*zoomLevel,hexWidth=2*hexSize,hexHeight=hexSize*Math.sqrt(3)),void 0!==t.boardOffsetX&&(boardOffsetX=t.boardOffsetX),void 0!==t.boardOffsetY&&(boardOffsetY=t.boardOffsetY),t.selectedCards||(t.selectedCards=[]),!t.setupLeaderPlaced){t.setupLeaderPlaced={1:!1,2:!1};for(let e=0;e<11;e++)for(let a=0;a<11;a++){const o=t.board[e][a];o&&"joker"===o.suit&&(t.setupLeaderPlaced[o.owner]=!0)}}return t}}catch(e){console.warn("Failed to load game state:",e)}return null}function saveStateToHistory(){const e={...gameState,cardsMovedThisTurn:new Set(gameState.cardsMovedThisTurn),cardsAttackedThisTurn:new Set(gameState.cardsAttackedThisTurn),cardsAttackExhaustion:new Map(gameState.cardsAttackExhaustion),board:gameState.board.map(e=>[...e]),players:{1:{...gameState.players[1],hand:[...gameState.players[1].hand],captured:[...gameState.players[1].captured],discarded:[...gameState.players[1].discarded],deck:[...gameState.players[1].deck]},2:{...gameState.players[2],hand:[...gameState.players[2].hand],captured:[...gameState.players[2].captured],discarded:[...gameState.players[2].discarded],deck:[...gameState.players[2].deck]}},selectedCards:[...gameState.selectedCards]};gameHistory.push(e),gameHistory.length>10&&gameHistory.shift()}function undoLastMove(){if(localStorage.setItem("tcg-has-interacted","true"),aiEnabled[gameState.currentPlayer])return console.log("Undo not allowed during AI turn"),!1;if(0===gameHistory.length)return console.log("No moves to undo"),!1;const e=gameHistory.pop();return gameState.currentPlayer=e.currentPlayer,gameState.phase=e.phase,gameState.turn=e.turn,gameState.board=e.board.map(e=>[...e]),gameState.players={1:{...e.players[1],hand:[...e.players[1].hand],captured:[...e.players[1].captured],discarded:[...e.players[1].discarded],deck:[...e.players[1].deck]},2:{...e.players[2],hand:[...e.players[2].hand],captured:[...e.players[2].captured],discarded:[...e.players[2].discarded],deck:[...e.players[2].deck]}},gameState.setupStep=e.setupStep,gameState.setupCardsPlaced={...e.setupCardsPlaced},gameState.setupLeaderPlaced={...e.setupLeaderPlaced},gameState.leaderAttackedThisTurn=e.leaderAttackedThisTurn,gameState.cardsMovedThisTurn=new Set(e.cardsMovedThisTurn),gameState.cardsAttackedThisTurn=new Set(e.cardsAttackedThisTurn),gameState.cardsAttackExhaustion=new Map(e.cardsAttackExhaustion||[]),clearSelection(),updateCanvas(),updateUI(),saveGameState(),console.log("Move undone"),!0}function clearSavedGame(){try{localStorage.removeItem("tcg-game-state")}catch(e){console.warn("Failed to clear saved game:",e)}}function analyzeFormationNeeds(e){const t=[],a=[],o=findLeaderPosition(e),r=1===e?2:1;for(let o=0;o<11;o++)for(let n=0;n<11;n++){const s=gameState.board[o][n];s&&s.owner===e?t.push({card:s,row:o,col:n}):s&&s.owner===r&&a.push({card:s,row:o,col:n})}if(!o||0===t.length)return{needsFrontLine:!0,frontLineCards:[],supportCards:[],enemyCenter:null};const[n,s]=o;let l=null;if(a.length>0){const e=a.reduce((e,{row:t})=>e+t,0)/a.length,t=a.reduce((e,{col:t})=>e+t,0)/a.length;l=[Math.round(e),Math.round(t)]}const d=[],i=[];for(const{card:e,row:a,col:o}of t){if("joker"===e.suit)continue;const t=Math.abs(a-n)+Math.abs(o-s);let r=!1;if(l){const e=Math.abs(n-l[0])+Math.abs(s-l[1]);r=Math.abs(a-l[0])+Math.abs(o-l[1])<e||t>=2&&t<=4}else r=t>=2&&t<=4;r?d.push({card:e,row:a,col:o}):i.push({card:e,row:a,col:o})}return{needsFrontLine:d.length<Math.min(3,t.length-1),frontLineCards:d,supportCards:i,enemyCenter:l,leaderPos:[n,s]}}function findFrontLineFormationMove(e){const t=analyzeFormationNeeds(e);if(!t.leaderPos)return null;const[a,o]=t.leaderPos;if(t.needsFrontLine&&t.supportCards.length>0){console.log(`[AI DEBUG] Formation needs front-line cards (${t.frontLineCards.length} < 3)`);for(const{card:r,row:n,col:s}of t.supportCards){if(isCardExhausted(r)||"diamonds"===r.suit)continue;const l=getValidMoves(r,n,s);let d=null,i=-1;for(const[c,u]of l){let l=0;const g=Math.abs(c-a)+Math.abs(u-o),m=Math.abs(n-a)+Math.abs(s-o);if(g>m&&(l+=20*(g-m)),g>=2&&g<=4?l+=40:g>4&&(l-=10),t.enemyCenter){Math.abs(c-t.enemyCenter[0])+Math.abs(u-t.enemyCenter[1])<Math.abs(a-t.enemyCenter[0])+Math.abs(o-t.enemyCenter[1])&&(l+=30)}l+=15*getHexNeighbors(c,u).filter(([t,a])=>{const o=gameState.board[t][a];return o&&o.owner===e&&"joker"!==o.suit}).length;!willCardBeThreatenedAtPosition(r,c,u,e)||(l-=50),l>i&&(i=l,d=[c,u])}if(d&&i>20)return console.log(`[AI DEBUG] Moving ${r.value}${r.suit} to front-line position [${d[0]},${d[1]}] (score: ${i})`),{type:"front_line_formation",card:r,fromRow:n,fromCol:s,toRow:d[0],toCol:d[1]}}}const r=t.frontLineCards.filter(({card:t,row:a,col:o})=>{if(isCardExhausted(t))return!1;return getHexNeighbors(a,o).filter(([t,a])=>{const o=gameState.board[t][a];return o&&o.owner===e&&"joker"!==o.suit}).length<=1});if(r.length>0){console.log(`[AI DEBUG] ${r.length} front-line cards need better cohesion`);for(const{card:t,row:n,col:s}of r){const r=getValidMoves(t,n,s);let l=null,d=-1;for(const[n,s]of r){const r=getHexNeighbors(n,s).filter(([t,a])=>{const o=gameState.board[t][a];return o&&o.owner===e&&"joker"!==o.suit}).length,i=Math.abs(n-a)+Math.abs(s-o);let c=25*r;i>=2&&i<=4&&(c+=20);!willCardBeThreatenedAtPosition(t,n,s,e)||(c-=30),c>d&&(d=c,l=[n,s])}if(l&&d>=30)return console.log(`[AI DEBUG] Improving front-line cohesion: ${t.value}${t.suit} to [${l[0]},${l[1]}] (score: ${d})`),{type:"front_line_cohesion",card:t,fromRow:n,fromCol:s,toRow:l[0],toCol:l[1]}}}return null}function findDiamondFlankingMove(e){const t=1===e?2:1,a=[],o=[];for(let r=0;r<11;r++)for(let n=0;n<11;n++){const s=gameState.board[r][n];s&&s.owner===e&&"diamonds"===s.suit&&!isCardExhausted(s)?a.push({card:s,row:r,col:n}):s&&s.owner===t&&o.push({card:s,row:r,col:n})}if(0===a.length)return null;let r=null;for(const{card:e,row:t,col:a}of o)if("joker"===e.suit){r=[t,a];break}const n=[Math.round(o.reduce((e,{row:t})=>e+t,0)/o.length),Math.round(o.reduce((e,{col:t})=>e+t,0)/o.length)];console.log(`[AI DEBUG] Diamond flanking analysis: ${a.length} diamonds, enemy center at [${n[0]},${n[1]}], leader at ${r}`);for(const{card:s,row:l,col:d}of a){const a=getValidMoves(s,l,d);let i=null,c=-1;for(const[l,d]of a){let a=0,u=0;if((1===t&&l<=1||2===t&&l>=9)&&(u+=60,console.log(`[AI DEBUG] Diamond flanking from behind enemy territory at [${l},${d}]`)),r){const e=r[0];(1===t&&l<e||2===t&&l>e)&&(u+=40,console.log("[AI DEBUG] Diamond positioning behind enemy leader"));const a=1===t?0:10,o=1===t?10:0;Math.abs(l-o)<Math.abs(l-a)&&(u+=30)}a+=u;let g=0;const m=getValidAttacks(s,l,d),f=[];for(const[e,a]of m){const o=gameState.board[e][a];o&&o.owner===t&&s.attack>=o.defense&&(f.push(o),g+=o.attack+o.defense,"joker"===o.suit&&(g+=100),f.length>1&&(g+=30))}a+=g;const h=Math.abs(l-n[0])+Math.abs(d-n[1]);h>=1&&h<=3?a+=25:h>5&&(a-=20);let p=0;for(const{card:e,row:a,col:r}of o){if(Math.abs(l-a)+Math.abs(d-r)<=2){p+=10;getHexNeighbors(a,r).filter(([e,a])=>{const o=gameState.board[e][a];return o&&o.owner===t}).length>=2&&(p+=15)}}a+=p;!willCardBeThreatenedAtPosition(s,l,d,e)?a+=10:a-=25,a>c&&(c=a,i=[l,d])}if(i&&c>10)return console.log(`[AI DEBUG] Diamond ${s.value}${s.suit} MANDATORY flanking maneuver to [${i[0]},${i[1]}] (score: ${c}) - diamonds always flank enemy leader from behind`),{type:"diamond_formation_break",card:s,fromRow:l,fromCol:d,toRow:i[0],toCol:i[1]}}for(const{card:o,row:r,col:n}of a){const a=getValidMoves(o,r,n);if(0===a.length)continue;let s=null,l=-1;for(const[r,n]of a){let a=0;a+=1===t?10*(10-r):10*r;const d=5;a+=5*Math.abs(n-d);!willCardBeThreatenedAtPosition(o,r,n,e)?a+=15:a-=10,a>l&&(l=a,s=[r,n])}if(s&&l>0)return console.log(`[AI DEBUG] Diamond ${o.value}${o.suit} MANDATORY repositioning for flanking to [${s[0]},${s[1]}] (score: ${l}) - diamonds always stay active`),{type:"diamond_reposition",card:o,fromRow:r,fromCol:n,toRow:s[0],toCol:s[1]}}return null}function calculateLeaderThreatVectors(e){const t=findLeaderPosition(e);if(!t)return[];const[a,o]=t,r=1===e?2:1,n=[];for(let e=0;e<11;e++)for(let t=0;t<11;t++){const s=gameState.board[e][t];if(s&&s.owner===r&&!isCardExhausted(s)){const r=Math.abs(e-a)+Math.abs(t-o);if(r<=5&&s.attack>0){const l={rowDir:e<a?-1:e>a?1:0,colDir:t<o?-1:t>o?1:0};n.push({enemyCard:s,enemyRow:e,enemyCol:t,distance:r,direction:l,threatLevel:s.attack,canCurrentlyAttack:r<=2})}}}return n.sort((e,t)=>e.distance-t.distance)}function findProtectivePositions(e,t){const a=findLeaderPosition(e);if(!a)return[];const[o,r]=a,n=[];for(const a of t){const t=[];let s=a.enemyRow,l=a.enemyCol;for(;Math.abs(s-o)>1||Math.abs(l-r)>1;)if(s<o?s++:s>o&&s--,l<r?l++:l>r&&l--,s>=0&&s<11&&l>=0&&l<11){const n=gameState.board[s][l];if(!n||n.owner===e&&"joker"!==n.suit){const e=Math.abs(s-o)+Math.abs(l-r);t.push({row:s,col:l,blocksEnemyAt:[a.enemyRow,a.enemyCol],threatLevel:a.threatLevel,distanceToLeader:e,isEmptyPosition:!n,priority:a.canCurrentlyAttack?100:50-5*a.distance})}}n.push(...t)}return n.filter((e,t,a)=>a.findIndex(t=>t.row===e.row&&t.col===e.col)===t).sort((e,t)=>t.priority-e.priority)}function findProtectiveSummonPosition(e){const t=calculateLeaderThreatVectors(e);if(0===t.length)return null;const a=findProtectivePositions(e,t),o=findLeaderPosition(e),r=gameState.players[e].hand;if(!o||0===a.length||0===r.length)return null;const[n,s]=o,l=getHexNeighbors(n,s),d=a.filter(e=>l.some(([t,a])=>t===e.row&&a===e.col));if(0===d.length)return null;const i=r.reduce((e,t)=>{const a=2*e.attack+e.defense+getCardValuePriority(e);return 2*t.attack+t.defense+getCardValuePriority(t)>a?t:e}),c=d.reduce((t,a)=>{let r=t.priority,n=a.priority;return r+=isInFrontOfLeader(e,o,t.row,t.col)?30:-10,n+=isInFrontOfLeader(e,o,a.row,a.col)?30:-10,n>r?a:t});return console.log(`[AI DEBUG] Protective summoning: ${i.value}${i.suit} at [${c.row},${c.col}] blocks threat from [${c.blocksEnemyAt[0]},${c.blocksEnemyAt[1]}]`),{card:i,row:c.row,col:c.col,protectionType:"threat_blocking",threatLevel:c.threatLevel}}function findProtectiveMovement(e){const t=calculateLeaderThreatVectors(e);if(0===t.length)return null;const a=findProtectivePositions(e,t);if(0===a.length)return null;const o=[];for(let t=0;t<11;t++)for(let a=0;a<11;a++){const r=gameState.board[t][a];r&&r.owner===e&&"joker"!==r.suit&&!isCardExhausted(r)&&o.push({card:r,row:t,col:a})}for(const{card:t,row:r,col:n}of o){const o=getValidMoves(t,r,n);for(const s of a)if(o.some(([e,t])=>e===s.row&&t===s.col)){if(!willCardBeThreatenedAtPosition(t,s.row,s.col,e)||s.priority>=100)return console.log(`[AI DEBUG] Protective movement: ${t.value}${t.suit} from [${r},${n}] to [${s.row},${s.col}] blocks threat from [${s.blocksEnemyAt[0]},${s.blocksEnemyAt[1]}]`),{type:"protective_blocking",card:t,fromRow:r,fromCol:n,toRow:s.row,toCol:s.col,threatLevel:s.threatLevel}}}return null}function isInFrontOfLeader(e,t,a,o){if(!t)return!1;const[r,n]=t;return 1===e?a>r:a<r}function calculateFrontLineBonus(e,t,a,o){if(!t)return 0;const[r,n]=t,s=Math.abs(a-r)+Math.abs(o-n);let l=0;return isInFrontOfLeader(e,t,a,o)?(l+=60,s>=2&&s<=3?l+=40:1===s?l+=20:s>=4&&s<=5&&(l+=10)):l-=30,l}const suits=["hearts","diamonds","clubs","spades"],values=["A","2","3","4","5","6","7","8","9","10"];function getCardValuePriority(e){if("joker"===e.suit)return 15;return-1===values.indexOf(e.value)?0:"A"===e.value?1:parseInt(e.value)}function getPlayerColor(e){return 1===e.owner?"#87ceeb":2===e.owner?"#ffd700":"#ffffff"}function getSuitColor(e,t=null){switch(e){case"hearts":return"#dc3545";case"diamonds":return"#fd7e14";case"clubs":return"#198754";case"spades":return"#9966ff";case"joker":return t?getPlayerColor(t):"#ffd700";default:return"#ffffff"}}const suitSymbols={hearts:"â™¥",diamonds:"â™¦",clubs:"â™£",spades:"â™ "};function getHexNeighbors(e,t){const a=[],o=[[1,1],[1,-1],[-1,0],[0,1],[1,0],[0,-1]];t%2==0&&(o[0][0]=-1,o[1][0]=-1);for(const[r,n]of o){const o=e+r,s=t+n;o>=0&&o<11&&s>=0&&s<11&&isValidHex(o,s)&&a.push([o,s])}return a}function getDistance(e,t,a,o){if(getHexNeighbors(e,t).some(([e,t])=>e===a&&t===o))return 1;const r=Math.abs(a-e),n=Math.abs(o-t);return Math.max(r,n)}function isInPlayerTerritory(e,t,a){return 1===a?e>=5:e<5}function getActualPlayerTerritory(e,t,a){return isInPlayerTerritory(e,t,a)}function createDeck(){const e=[];for(const t of suits)for(const a of values)e.push({suit:t,value:a,attack:getCardAttack(a),defense:getCardDefense(a,t),id:`${t}_${a}_${Math.random()}`,faceDown:!1,owner:null});return e.push({suit:"joker",value:"JOKER",attack:0,defense:0,id:`joker_${Math.random()}`,faceDown:!1,owner:null}),shuffleDeck(e)}function getCardAttack(e){return"A"===e?1:parseInt(e)||0}function getCardDefense(e,t){const a=getCardAttack(e);return"spades"===t?2*a:"clubs"===t?a+5:a}function shuffleDeck(e){for(let t=e.length-1;t>0;t--){const a=Math.floor(Math.random()*(t+1));[e[t],e[a]]=[e[a],e[t]]}return e}function getHexCorners(e,t){const a=[];for(let o=0;o<6;o++){const r=Math.PI/3*o;a.push({x:e+hexSize*Math.cos(r),y:t+hexSize*Math.sin(r)})}return a}function hexToPixel(e,t){const a=1.5*hexSize*e+boardOffsetX,o=hexSize*Math.sqrt(3)*(t+e%2*.5)+boardOffsetY;if(mapRotated){return{x:(canvas.logicalWidth||canvas.width)-a,y:(canvas.logicalHeight||canvas.height)-o}}return{x:a,y:o}}function pixelToHex(e,t){let a=e,o=t;if(mapRotated){a=(canvas.logicalWidth||canvas.width)-e,o=(canvas.logicalHeight||canvas.height)-t}const r=(a-boardOffsetX)/(1.5*hexSize),n=Math.round(r),s=(o-boardOffsetY)/(hexSize*Math.sqrt(3))-n%2*.5,l=Math.round(s);return n>=0&&n<11&&l>=0&&l<11&&isValidHex(l,n)?{col:n,row:l}:null}function findFallbackSummonAction(e){console.log(`[AI DEBUG] Finding fallback summon action for player ${e}`);const t=findLeaderPosition(e);if(!t||0===gameState.players[e].hand.length)return null;const a=countCardsOnMap(e),o=a.regularCards<5;if(gameState.leaderAttackedThisTurn&&!o)return console.log(`[AI DEBUG] Leader attacked this turn, but not forcing due to card count (${a.regularCards} >= 5)`),null;o&&console.log(`[AI DEBUG] FALLBACK SUMMON REQUIRED: Only ${a.regularCards} regular cards (< 5) - forcing fallback summoning`);const r=getHexNeighbors(t[0],t[1]).find(([t,a])=>{if(t>=0&&t<11&&a>=0&&a<11){const o=gameState.board[t][a];return!o||o.owner===e}return!1});if(r&&gameState.players[e].hand.length>0){const t=gameState.players[e].hand.reduce((e,t)=>{const a=getCardValuePriority(e);return getCardValuePriority(t)>a?t:e});return console.log(`[AI DEBUG] Fallback summon: highest value card ${t.value}${t.suit} (priority: ${getCardValuePriority(t)}) to [${r[0]},${r[1]}]`),{card:t,row:r[0],col:r[1]}}return null}function findFallbackReplaceAction(e){if(console.log(`[AI DEBUG] Finding fallback replace action for player ${e}`),gameState.leaderAttackedThisTurn||0===gameState.players[e].hand.length)return null;for(let t=0;t<11;t++)for(let a=0;a<11;a++){const o=gameState.board[t][a];if(o&&o.owner===e){let r=null,n=-1;for(const t of gameState.players[e].hand){const e=o.attack+o.defense,a=t.attack+t.defense;if(a>=e){const o=a-e+2*getCardValuePriority(t);o>n&&(n=o,r=t)}}if(r){const e=o.attack+o.defense,n=r.attack+r.defense;return console.log(`[AI DEBUG] Fallback replace: ${o.value}${o.suit} (${e}) with ${r.value}${r.suit} (${n}, priority: ${getCardValuePriority(r)}) at [${t},${a}]`),{row:t,col:a,oldCard:o,newCard:r}}}}return null}function findFallbackRepositionAction(e){console.log(`[AI DEBUG] Finding fallback reposition action for player ${e}`);for(let t=0;t<11;t++)for(let a=0;a<11;a++){const o=gameState.board[t][a];if(o&&o.owner===e&&!isCardExhausted(o)){const e=getValidMoves(o,t,a);if(e.length>0){const r=e[0];return console.log(`[AI DEBUG] Fallback reposition: ${o.value}${o.suit} from [${t},${a}] to [${r[0]},${r[1]}]`),{card:o,fromRow:t,fromCol:a,toRow:r[0],toCol:r[1]}}}}return null}function findAnyLegalAction(e){console.log(`[AI DEBUG] Finding ANY legal action for player ${e}`);for(let t=0;t<11;t++)for(let a=0;a<11;a++){const o=gameState.board[t][a];if(o&&o.owner===e&&!isCardExhausted(o)){const e=getValidMoves(o,t,a);if(e.length>0)return{type:"move",fromRow:t,fromCol:a,toRow:e[0][0],toCol:e[0][1]};const r=getValidAttacks(o,t,a);if(r.length>0)return{type:"attack",fromRow:t,fromCol:a,toRow:r[0][0],toCol:r[0][1]}}}return null}function isValidHex(e,t){return 0!==e||t%2!=0}function drawHexagon(e,t,a,o="#666",r=2){const n=getHexCorners(e,t);ctx.beginPath(),ctx.moveTo(n[0].x,n[0].y);for(let e=1;e<6;e++)ctx.lineTo(n[e].x,n[e].y);ctx.closePath(),a&&(ctx.fillStyle=a,ctx.fill()),o&&(ctx.strokeStyle=o,ctx.lineWidth=r,ctx.stroke())}function showFlashCaption(e,t="default",a=2e3){const o=document.getElementById("flash-caption"),r=document.getElementById("flash-text");r.className="","default"!==t&&r.classList.add(t),r.textContent=e,o.classList.remove("hidden"),o.classList.add("visible"),setTimeout(()=>{o.classList.remove("visible"),o.classList.add("hidden")},a)}function showSetupCaption(){showFlashCaption("SETUP PHASE","setup",1e3)}function showBattleCaption(){showFlashCaption("BATTLE BEGINS!","battle",1e3)}function showPlayerTurnCaption(e){showFlashCaption(`PLAYER ${e}`,1===e?"player1":"player2",1e3)}function showPlayerWinCaption(e){showFlashCaption(`PLAYER ${e} WINS!`,"win",1e4)}function startFadeOutAnimation(e,t,a="captured",o=null){const r=hexToPixel(t[1],t[0]),n=document.getElementById("hex-canvas").getBoundingClientRect(),s=2*hexSize,l=2.8*hexSize,d=s/2,i=l/2,c=getPlayerColor(e),u=e.faceDown?"#888":getSuitColor(e.suit,e);function g(t=""){const o=document.createElement("div");if(o.className=`card card-fade-overlay ${a} ${t}`,o.style.position="absolute",o.style.left=Math.round(n.left+r.x-d)+"px",o.style.top=Math.round(n.top+r.y-i)+"px",o.style.setProperty("width",Math.round(s)+"px","important"),o.style.setProperty("height",Math.round(l)+"px","important"),o.style.zIndex="1006",o.style.pointerEvents="none",o.style.border=`3px solid ${c}`,o.style.backgroundColor=e.faceDown?"#333":c,"joker"===e.suit&&o.classList.add("joker",`player${e.owner}`),!e.faceDown){const t=document.createElement("div");t.className="card-value",t.style.fontSize=1*hexSize+"px",t.style.color=u,t.textContent="joker"===e.suit?"â˜…":e.value,o.appendChild(t);const a=document.createElement("div");a.className="card-suit",a.style.fontSize=1.1*hexSize+"px",a.style.color=u,a.textContent=getSuitSymbol(e.suit),o.appendChild(a)}return o}const m="captured"===a?1600:2e3,f=[];if("captured"===a){const e=g("captured-top");e.style.boxShadow="0 0 30px rgba(255, 215, 0, 0.8)",document.body.appendChild(e),fadeOutElements.push(e),f.push(e);const t=g("captured-bottom");t.style.boxShadow="0 0 30px rgba(255, 215, 0, 0.8)",document.body.appendChild(t),fadeOutElements.push(t),f.push(t),requestAnimationFrame(()=>{e.classList.add("fade-out"),t.classList.add("fade-out")})}else{const e=g(),t=document.createElement("div");t.style.position="absolute",t.style.top="-15px",t.style.right="-15px",t.style.fontSize=.9*hexSize+"px",t.style.fontWeight="bold","discarded"===a&&(t.textContent="ðŸ’€",t.style.color="#ff4444",e.style.boxShadow="0 0 30px rgba(255, 68, 68, 0.8)"),e.appendChild(t),document.body.appendChild(e),fadeOutElements.push(e),f.push(e),requestAnimationFrame(()=>{e.classList.add("fade-out"),o&&(e.style.animation="battle-casualty 1.6s ease-out")})}gameState.board[t[0]][t[1]]=null,setTimeout(()=>{f.forEach(e=>{e.parentNode&&e.parentNode.removeChild(e),fadeOutElements=fadeOutElements.filter(t=>t!==e)}),updateCanvas()},m)}function startLeaderAttackAnimation(e,t){const a=hexToPixel(t[1],t[0]),o=document.getElementById("hex-canvas").getBoundingClientRect(),r=document.createElement("div");r.className="card card-fade-overlay leader-attacked";const n=2*hexSize,s=2.8*hexSize,l=n/2,d=s/2;r.style.position="absolute",r.style.left=Math.round(o.left+a.x-l)+"px",r.style.top=Math.round(o.top+a.y-d)+"px",r.style.setProperty("width",Math.round(n)+"px","important"),r.style.setProperty("height",Math.round(s)+"px","important"),r.style.zIndex="1002",r.style.pointerEvents="none",r.style.border="4px solid #ff0000",r.style.backgroundColor="rgba(255, 0, 0, 0.9)",r.style.boxShadow="0 0 40px rgba(255, 0, 0, 1), 0 0 80px rgba(255, 100, 100, 0.5)",r.style.borderRadius="8px",r.classList.add("joker",`player${e.owner}`);const i=document.createElement("div");i.className="card-value",i.textContent="â˜…",i.style.color="#fff",i.style.fontSize=1.3*hexSize+"px",r.appendChild(i);const c=document.createElement("div");c.className="card-suit",c.textContent="ðŸ’¥",c.style.color="#fff",c.style.fontSize=.9*hexSize+"px",r.appendChild(c),document.body.appendChild(r),fadeOutElements.push(r),requestAnimationFrame(()=>{r.classList.add("fade-out")}),setTimeout(()=>{r.parentNode&&r.parentNode.removeChild(r),fadeOutElements=fadeOutElements.filter(e=>e!==r)},2e3)}function startReplacementAnimation(e,t,a){const o=hexToPixel(a[1],a[0]),r=document.getElementById("hex-canvas").getBoundingClientRect(),n=2*hexSize,s=2.8*hexSize,l=n/2,d=s/2,i=document.createElement("div");i.className="card card-fade-overlay replacement-old",i.style.position="absolute",i.style.left=Math.round(r.left+o.x-l)+"px",i.style.top=Math.round(r.top+o.y-d)+"px",i.style.setProperty("width",Math.round(n)+"px","important"),i.style.setProperty("height",Math.round(s)+"px","important"),i.style.zIndex="1003",i.style.pointerEvents="none";const c=getPlayerColor(e),u=getSuitColor(e.suit,e);if(i.style.border=`2px solid ${c}`,i.style.backgroundColor=c,!e.faceDown){const t=document.createElement("div");t.className="card-value",t.style.fontSize=.9*hexSize+"px",t.style.color=u,t.textContent="joker"===e.suit?"â˜…":e.value,i.appendChild(t);const a=document.createElement("div");a.className="card-suit",a.style.fontSize=1*hexSize+"px",a.style.color=u,a.textContent=getSuitSymbol(e.suit),i.appendChild(a)}const g=document.createElement("div");g.className="card card-fade-overlay replacement-new",g.style.position="absolute",g.style.left=Math.round(r.left+o.x-l)+"px",g.style.top=Math.round(r.top+o.y-d)+"px",g.style.setProperty("width",Math.round(n)+"px","important"),g.style.setProperty("height",Math.round(s)+"px","important"),g.style.zIndex="1004",g.style.pointerEvents="none",g.style.opacity="0",g.style.transform="scale(0.5)";const m=getPlayerColor(t),f=getSuitColor(t.suit,t);if(g.style.border=`2px solid ${m}`,g.style.backgroundColor=m,!t.faceDown){const e=document.createElement("div");e.className="card-value",e.style.fontSize=.9*hexSize+"px",e.style.color=f,e.textContent="joker"===t.suit?"â˜…":t.value,g.appendChild(e);const a=document.createElement("div");a.className="card-suit",a.style.fontSize=1*hexSize+"px",a.style.color=f,a.textContent=getSuitSymbol(t.suit),g.appendChild(a)}document.body.appendChild(i),document.body.appendChild(g),fadeOutElements.push(i,g),requestAnimationFrame(()=>{i.classList.add("fade-out"),setTimeout(()=>{g.classList.add("fade-in")},1600)}),setTimeout(()=>{[i,g].forEach(e=>{e.parentNode&&e.parentNode.removeChild(e)}),fadeOutElements=fadeOutElements.filter(e=>e!==i&&e!==g),updateCanvas()},3600)}function startAttackAnimation(e,t,a=null){if(!e||0===e.length)return;const o=document.getElementById("hex-canvas").getBoundingClientRect(),r=hexToPixel(t[1],t[0]),n=gameState.board[t[0]][t[1]];n&&setTimeout(()=>{const e=document.createElement("div");let t="";a&&(t=a.targetCaptured&&"joker"!==n.suit?"captured":a.isLeaderAttack?"leader":"survived"),e.className=`card card-fade-overlay target-highlight ${t}`;const s=2*hexSize,l=2.8*hexSize,d=s/2,i=l/2;if(e.style.position="absolute",e.style.left=Math.round(o.left+r.x-d)+"px",e.style.top=Math.round(o.top+r.y-i)+"px",e.style.setProperty("width",Math.round(s)+"px","important"),e.style.setProperty("height",Math.round(l)+"px","important"),e.style.zIndex="1004",e.style.pointerEvents="none","captured"===t?(e.style.border="3px solid #ffd700",e.style.boxShadow="0 0 30px 8px #ffd700, 0 0 60px 16px #fff20044"):"survived"===t?(e.style.border="3px solid #3399ff",e.style.boxShadow="0 0 30px 8px #3399ff, 0 0 60px 16px #00e0ff44"):(e.style.border="3px solid #ff4444",e.style.boxShadow="0 0 20px rgba(255, 68, 68, 0.8), 0 0 40px rgba(255, 68, 68, 0.4)"),e.style.backgroundColor=getPlayerColor(n),"joker"===n.suit&&e.classList.add("joker",`player${n.owner}`),!n.faceDown){const t=document.createElement("div");t.className="card-value",t.style.fontSize=1*hexSize+"px",t.style.color=getSuitColor(n.suit,n),t.textContent="joker"===n.suit?"â˜…":n.value,e.appendChild(t);const a=document.createElement("div");a.className="card-suit",a.style.fontSize=1.1*hexSize+"px",a.style.color=getSuitColor(n.suit,n),a.textContent=getSuitSymbol(n.suit),e.appendChild(a)}const c=document.createElement("div");if(c.style.position="absolute",c.style.top="-10px",c.style.left="-10px",c.style.fontSize=.7*hexSize+"px",c.style.color="#ff4444",c.textContent="ðŸŽ¯",e.appendChild(c),a){const a=document.createElement("div");a.style.position="absolute",a.style.bottom="-10px",a.style.right="-10px",a.style.fontSize=.8*hexSize+"px",a.style.fontWeight="bold","captured"===t?(a.textContent="ðŸ†",a.style.color="#ffd700"):"survived"===t?(a.textContent="ðŸ›¡ï¸",a.style.color="#3399ff"):"leader"===t&&(a.textContent="ðŸ’¥",a.style.color="#ffd700"),e.appendChild(a)}document.body.appendChild(e),fadeOutElements.push(e),e.offsetHeight,requestAnimationFrame(()=>{e.classList.add("defending")});setTimeout(()=>{e.parentNode&&e.parentNode.removeChild(e),fadeOutElements=fadeOutElements.filter(t=>t!==e)},600)},200);const s=2*hexSize,l=2.8*hexSize,d=s/2,i=l/2;e.forEach((e,t)=>{const r=e.card||e,n=e.position||findCardPosition(r);if(!n)return;const c=hexToPixel(n[1],n[0]);let u="",g=!1;a&&(g=a.attackersCasualites&&a.attackersCasualites.some(e=>e.id===r.id),u=g&&"joker"!==r.suit?"discarded":"survived");const m=document.createElement("div");if(m.className=`card card-fade-overlay attacker-highlight ${u}`,m.style.position="absolute",m.style.left=Math.round(o.left+c.x-d)+"px",m.style.top=Math.round(o.top+c.y-i)+"px",m.style.setProperty("width",Math.round(s)+"px","important"),m.style.setProperty("height",Math.round(l)+"px","important"),m.style.zIndex="1005",m.style.pointerEvents="none","discarded"===u?(m.style.border="3px solid #ff4444",m.style.boxShadow="0 0 30px 8px #ff4444, 0 0 60px 16px #ff000044"):"survived"===u?(m.style.border="3px solid #3399ff",m.style.boxShadow="0 0 30px 8px #3399ff, 0 0 60px 16px #00e0ff44"):(m.style.border="3px solid #ffd700",m.style.boxShadow="0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4)"),m.style.backgroundColor=getPlayerColor(r),"joker"===r.suit&&m.classList.add("joker",`player${r.owner}`),!r.faceDown){const e=document.createElement("div");e.className="card-value",e.style.fontSize=1*hexSize+"px",e.style.color=getSuitColor(r.suit,r),e.textContent="joker"===r.suit?"â˜…":r.value,m.appendChild(e);const t=document.createElement("div");t.className="card-suit",t.style.fontSize=1.1*hexSize+"px",t.style.color=getSuitColor(r.suit,r),t.textContent=getSuitSymbol(r.suit),m.appendChild(t)}const f=document.createElement("div");if(f.style.position="absolute",f.style.top="-10px",f.style.right="-10px",f.style.fontSize=.7*hexSize+"px",f.style.color="#ff4444",f.textContent="âš”ï¸",m.appendChild(f),a){const e=document.createElement("div");e.style.position="absolute",e.style.bottom="-10px",e.style.left="-10px",e.style.fontSize=.8*hexSize+"px",e.style.fontWeight="bold","discarded"===u?(e.textContent="ðŸ’€",e.style.color="#ff4444"):"survived"===u?(e.textContent="ðŸ›¡ï¸",e.style.color="#3399ff"):(e.textContent="ðŸ†",e.style.color="#ffd700"),m.appendChild(e)}document.body.appendChild(m),fadeOutElements.push(m),m.offsetHeight,setTimeout(()=>{requestAnimationFrame(()=>{m.classList.add("attacking")})},200*t);setTimeout(()=>{m.parentNode&&m.parentNode.removeChild(m),fadeOutElements=fadeOutElements.filter(e=>e!==m)},("survived"===u?1200:"discarded"===u?100:4e3)+200*t)})}function initGame(e=!1){canvas=document.getElementById("hex-canvas"),ctx=canvas.getContext("2d"),e||resizeCanvas(),hexWidth=2*hexSize,hexHeight=hexSize*Math.sqrt(3),canvas.addEventListener("click",handleCanvasClick),canvas.addEventListener("mousedown",handleMouseDown),canvas.addEventListener("mousemove",handleMouseMove),canvas.addEventListener("mouseup",handleMouseUp),canvas.addEventListener("wheel",handleMapZoom),canvas.addEventListener("touchstart",handleTouchStart,{passive:!1}),canvas.addEventListener("touchmove",handleTouchMove,{passive:!1}),canvas.addEventListener("touchend",handleTouchEnd,{passive:!1}),window.addEventListener("resize",resizeCanvas),document.addEventListener("click",handleMenuClose),document.addEventListener("touchend",handleMenuClose);document.getElementById("player-hand");if(e)console.log("New Game: Preserving current AI settings:",aiEnabled);else{localStorage.getItem("tcg-has-interacted")?(aiEnabled={1:!1,2:!0},console.log("Page loaded: Defaulting to P1 human vs P2 AI")):(aiEnabled={1:!0,2:!0},console.log("First time load: Starting bot vs bot demo"))}const t=loadGameState();if(t)gameState=t,gameState.selectedCards||(gameState.selectedCards=[]),gameState.cardsMovedThisTurn instanceof Set||(gameState.cardsMovedThisTurn=new Set(gameState.cardsMovedThisTurn||[])),gameState.cardsAttackedThisTurn instanceof Set||(gameState.cardsAttackedThisTurn=new Set(gameState.cardsAttackedThisTurn||[])),gameState.cardsAttackExhaustion instanceof Map||(gameState.cardsAttackExhaustion=new Map(Object.entries(gameState.cardsAttackExhaustion||{}))),console.log("Loaded saved game state (AI settings remain as default)");else{console.log("No saved state found, creating new game with default AI settings");const e=createDeck(),t=createDeck();e.forEach(e=>e.owner=1),t.forEach(e=>e.owner=2),gameState.players[1].leader=e.find(e=>"joker"===e.suit),gameState.players[2].leader=t.find(e=>"joker"===e.suit),gameState.players[1].deck=e.filter(e=>"joker"!==e.suit),gameState.players[2].deck=t.filter(e=>"joker"!==e.suit),gameState.players[1].hand.push(gameState.players[1].leader),gameState.players[2].hand.push(gameState.players[2].leader),drawCards(1,5),drawCards(2,5)}if(updateCanvas(),updateUI(),updateBoardCardOverlays(),updateCursor(null,null),updateMapFlippingForAI(),updateAllAIButtons(),initializeAIAggression(),e||localStorage.getItem("tcg-has-interacted")){const e=document.getElementById("try-playing-btn");e&&e.classList.add("hidden")}else{const e=document.getElementById("try-playing-btn");e&&e.classList.remove("hidden")}if("setup"===gameState.phase&&1===gameState.turn){showSetupCaption();findLeaderPosition(gameState.currentPlayer)||autoSelectLeaderForSetup(gameState.currentPlayer)}aiEnabled[gameState.currentPlayer]&&setTimeout(()=>{"setup"===gameState.phase?performAISetupMove(gameState.currentPlayer):"play"===gameState.phase&&performAIMove(gameState.currentPlayer)},2e3)}function getCanvasCoordinates(e){const t=canvas.getBoundingClientRect(),a=canvas.logicalWidth||canvas.width,o=canvas.logicalHeight||canvas.height;return{x:(e.clientX-t.left)*(a/t.width),y:(e.clientY-t.top)*(o/t.height)}}function resizeCanvas(){const e=window.devicePixelRatio||1,t=window.innerWidth,a=window.innerHeight;canvas.width=t*e,canvas.height=a*e,canvas.style.width=t+"px",canvas.style.height=a+"px",ctx.scale(e,e),canvas.logicalWidth=t,canvas.logicalHeight=a,ctx.setTransform(1,0,0,1,0,0),ctx.scale(e,e),hexWidth=2*hexSize,hexHeight=hexSize*Math.sqrt(3);const o=11*hexSize*1.5+.5*hexSize,r=11*hexSize*Math.sqrt(3);boardOffsetX=(t-o)/2,boardOffsetY=(a-r)/2;const n=window.innerWidth<=768;boardOffsetX=Math.max(boardOffsetX,n?20:50),boardOffsetY=Math.max(boardOffsetY,n?80:100),gameState.phase&&updateCanvas()}function handleMouseMove(e){const t=getCanvasCoordinates(e);if(lastMousePos={x:e.clientX,y:e.clientY},dragState.isDragging)return void handleDragMove(e,t);handleMapDrag(e);const a=pixelToHex(t.x,t.y),o=hoveredHex;if(a&&a.row>=0&&a.row<11&&a.col>=0&&a.col<11&&isValidHex(a.row,a.col)){hoveredHex=[a.row,a.col],updateCoordinateDisplay(a.col,a.row,e.clientX,e.clientY);const t=hoveredAttackTarget;"play"===gameState.phase&&gameState.validAttacks&&gameState.validAttacks.some(([e,t])=>e===a.row&&t===a.col)?(hoveredAttackTarget=[a.row,a.col],attackPreviewResults=calculateAttackResults(a.row,a.col)):(hoveredAttackTarget=null,attackPreviewResults=null),updateCursor(a.row,a.col);const r=!o!=!hoveredHex||o&&hoveredHex&&(o[0]!==hoveredHex[0]||o[1]!==hoveredHex[1]),n=!t!=!hoveredAttackTarget||t&&hoveredAttackTarget&&(t[0]!==hoveredAttackTarget[0]||t[1]!==hoveredAttackTarget[1]);(r||n)&&updateCanvas()}else{hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,updateCoordinateDisplay(null,null),updateCursor(null,null);(!o!=!hoveredHex||o&&hoveredHex&&(o[0]!==hoveredHex[0]||o[1]!==hoveredHex[1]))&&updateCanvas()}}function handleMouseDown(e){handDesktopDragState.isDragging||desktopDragState.isDragging||handleMapDragStart(e)}function handleMouseUp(e){handDesktopDragState.isDragging||desktopDragState.isDragging||(dragState.isDragging?handleDragEnd(e):handleMapDragEnd(e))}function startCardDrag(e,t,a,o,r){dragState.isDragging=!0,dragState.dragType=r,dragState.draggedCard=e,dragState.startX=a,dragState.startY=o,dragState.startHex=t,dragState.currentHex=t,isDraggingCard=!0,draggedCard=e;gameState.selectedCards&&gameState.selectedCards.some(t=>t.card===e)?(dragState.dragType="card-attack",console.log(`Started combined attack drag with ${gameState.selectedCards.length} cards`)):"card-move"===r&&(clearSelection(),selectCard(e,t.row,t.col),console.log(`Started single card drag with ${e.value}${e.suit}`))}function handleDragMove(e,t){const a=pixelToHex(t.x,t.y);if(a&&a.row>=0&&a.row<11&&a.col>=0&&a.col<11&&isValidHex(a.row,a.col)){const t=dragState.currentHex;if(dragState.currentHex=a,hoveredHex=[a.row,a.col],"card-move"===dragState.dragType){const e=gameState.board[a.row][a.col];if(e&&e.owner!==dragState.draggedCard.owner){if(gameState.validAttacks&&gameState.validAttacks.some(([e,t])=>e===a.row&&t===a.col)){const e=hoveredAttackTarget;hoveredAttackTarget=[a.row,a.col],e&&e[0]===a.row&&e[1]===a.col||(attackPreviewResults=calculateAttackResults(a.row,a.col))}}else hoveredAttackTarget=null,attackPreviewResults=null}t&&t.row===a.row&&t.col===a.col||updateCoordinateDisplay(a.col,a.row,e.clientX,e.clientY),t&&t.row===a.row&&t.col===a.col||requestDragUpdate()}}function handleDragEnd(e){if(!dragState.isDragging)return;const t=getCanvasCoordinates(e),a=pixelToHex(t.x,t.y);console.log(`Ending ${dragState.dragType} drag`),a&&a.row>=0&&a.row<11&&a.col>=0&&a.col<11&&isValidHex(a.row,a.col)&&("card-move"===dragState.dragType?handleCardDragEnd(a):"hand-summon"===dragState.dragType&&handleHandSummonDragEnd(a)),resetDragState()}function handleCardDragEnd(e){const t=dragState.draggedCard,a=dragState.startHex;if(gameState.selectedCards&&gameState.selectedCards.some(e=>e.card===t)){const a=gameState.board[e.row][e.col];return a&&a.owner!==t.owner&&gameState.validAttacks&&gameState.validAttacks.some(([t,a])=>t===e.row&&a===e.col)?void performCombinedAttack(e.row,e.col):void console.log("Invalid combined attack target")}const o=gameState.board[e.row][e.col];o&&o.owner!==t.owner&&gameState.validAttacks&&gameState.validAttacks.some(([t,a])=>t===e.row&&a===e.col)?performAttack(e.row,e.col):gameState.validMoves&&gameState.validMoves.some(([t,a])=>t===e.row&&a===e.col)?moveCard(a.row,a.col,e.row,e.col,t):a.row!==e.row||a.col!==e.col?console.log("Invalid drag target"):selectCard(t,a.row,a.col)}function resetDragState(){dragState.isDragging=!1,dragState.dragType=null,dragState.draggedCard=null,dragState.startHex=null,dragState.currentHex=null,isDraggingCard=!1,draggedCard=null,hoveredAttackTarget=null,attackPreviewResults=null,updateCanvas()}function updateBoardCardOverlays(){document.querySelectorAll(".board-card-overlay").forEach(e=>e.remove());for(let e=0;e<11;e++)for(let t=0;t<11;t++){if(!isValidHex(e,t))continue;const a=gameState.board[e][t];a&&a.owner===gameState.currentPlayer&&!isCardExhausted(a)&&createBoardCardOverlay(a,e,t)}}function createBoardCardOverlay(e,t,a){const o=hexToPixel(a,t),r=document.getElementById("hex-canvas").getBoundingClientRect(),n=document.createElement("div");n.className="board-card-overlay",n.dataset.cardId=e.id,n.dataset.row=t,n.dataset.col=a;const s=hexSize*(isTouchDevice?1:.8);n.style.position="absolute",n.style.left=r.left+o.x-s+"px",n.style.top=r.top+o.y-s+"px",n.style.width=2*s+"px",n.style.height=2*s+"px",n.style.backgroundColor="transparent",n.style.cursor=isTouchDevice?"default":"grab",n.style.zIndex="1000",n.style.pointerEvents="auto",isTouchDevice||(n.addEventListener("mouseenter",()=>{n.style.cursor="grab"}),n.addEventListener("mouseleave",()=>{n.style.cursor="grab"})),isTouchDevice?(n.addEventListener("touchstart",o=>handleBoardCardTouchStart(o,e,t,a),{passive:!1}),n.addEventListener("touchmove",handleBoardCardTouchMove,{passive:!1}),n.addEventListener("touchend",handleBoardCardTouchEnd,{passive:!1})):(n.addEventListener("mousedown",o=>handleBoardCardMouseStart(o,e,t,a)),n.addEventListener("mousemove",handleBoardCardMouseMove),n.addEventListener("mouseup",handleBoardCardMouseEnd),n.draggable=!1),document.body.appendChild(n)}let desktopDragState={isDragging:!1,draggedCard:null,startRow:null,startCol:null,startX:0,startY:0,currentX:0,currentY:0};function handleBoardCardMouseStart(e,t,a,o){e.preventDefault(),e.stopPropagation(),desktopDragState.isDragging=!0,desktopDragState.draggedCard=t,desktopDragState.startRow=a,desktopDragState.startCol=o,desktopDragState.startX=e.clientX,desktopDragState.startY=e.clientY,desktopDragState.currentX=e.clientX,desktopDragState.currentY=e.clientY,dragState.isDragging=!0,dragState.dragType="card-move",dragState.draggedCard=t,dragState.startHex={row:a,col:o},dragState.startX=e.clientX,dragState.startY=e.clientY,lastMousePos={x:e.clientX,y:e.clientY},selectedCards=[],showValidMovesAndAttacks(t,a,o),document.body.style.cursor="grabbing",document.addEventListener("mousemove",handleBoardCardMouseMove),document.addEventListener("mouseup",handleBoardCardMouseEnd),requestDragUpdate()}function handleBoardCardMouseMove(e){e.preventDefault(),e.stopPropagation(),desktopDragState.isDragging&&(desktopDragState.currentX=e.clientX,desktopDragState.currentY=e.clientY,lastMousePos={x:e.clientX,y:e.clientY},updateDragHoverPreview(e.clientX,e.clientY,desktopDragState.draggedCard,desktopDragState.startRow,desktopDragState.startCol),requestDragUpdate())}function handleBoardCardMouseEnd(e){if(e.preventDefault(),e.stopPropagation(),!desktopDragState.isDragging)return;document.removeEventListener("mousemove",handleBoardCardMouseMove),document.removeEventListener("mouseup",handleBoardCardMouseEnd),document.body.style.cursor="";if(Math.sqrt(Math.pow(desktopDragState.currentX-desktopDragState.startX,2)+Math.pow(desktopDragState.currentY-desktopDragState.startY,2))<10)console.log("Short drag detected, selecting card:",desktopDragState.draggedCard.value+desktopDragState.draggedCard.suit),dragState.originalSelection=null,handleMobileCardSelection(desktopDragState.draggedCard,desktopDragState.startRow,desktopDragState.startCol,e.ctrlKey);else{const t=getCanvasCoordinates({clientX:desktopDragState.currentX,clientY:desktopDragState.currentY}),a=pixelToHex(t.x,t.y);let o=!1;if(a&&isValidHex(a.row,a.col)){a.row===desktopDragState.startRow&&a.col===desktopDragState.startCol?(dragState.originalSelection=null,handleMobileCardSelection(desktopDragState.draggedCard,desktopDragState.startRow,desktopDragState.startCol,e.ctrlKey)):(o=processBoardCardDrag(desktopDragState.draggedCard,desktopDragState.startRow,desktopDragState.startCol,a.row,a.col),o&&autoSelectCardAfterDragAction(desktopDragState.draggedCard,a.row,a.col))}o||!a||!isValidHex(a.row,a.col)||a.row===desktopDragState.startRow&&a.col===desktopDragState.startCol||(dragState.originalSelection=null,handleMobileCardSelection(desktopDragState.draggedCard,desktopDragState.startRow,desktopDragState.startCol,e.ctrlKey))}desktopDragState.isDragging=!1,desktopDragState.draggedCard=null,dragState.isDragging=!1,dragState.dragType=null,dragState.draggedCard=null,gameState.selectedCard||gameState.selectedCards&&0!==gameState.selectedCards.length?(hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,dragState.originalSelection=null):clearDragHighlights(),updateCanvas()}let mobileDragState={isDragging:!1,draggedCard:null,startRow:null,startCol:null,startX:0,startY:0,currentX:0,currentY:0};function handleBoardCardTouchStart(e,t,a,o){if(e.preventDefault(),e.stopPropagation(),1!==e.touches.length)return;const r=e.touches[0];navigator.vibrate&&navigator.vibrate(50),mobileDragState.isDragging=!0,mobileDragState.draggedCard=t,mobileDragState.startRow=a,mobileDragState.startCol=o,mobileDragState.startX=r.clientX,mobileDragState.startY=r.clientY,mobileDragState.currentX=r.clientX,mobileDragState.currentY=r.clientY,dragState.isDragging=!0,dragState.dragType="card-move",dragState.draggedCard=t,dragState.startHex={row:a,col:o},dragState.startX=r.clientX,dragState.startY=r.clientY,lastMousePos={x:r.clientX,y:r.clientY},selectedCards=[],showValidMovesAndAttacks(mobileDragState.draggedCard,mobileDragState.startRow,mobileDragState.startCol),requestDragUpdate()}function handleBoardCardTouchMove(e){if(e.preventDefault(),e.stopPropagation(),!mobileDragState.isDragging||1!==e.touches.length)return;const t=e.touches[0];mobileDragState.currentX=t.clientX,mobileDragState.currentY=t.clientY,lastMousePos={x:t.clientX,y:t.clientY},updateDragHoverPreview(t.clientX,t.clientY,mobileDragState.draggedCard,mobileDragState.startRow,mobileDragState.startCol),requestDragUpdate()}function handleBoardCardTouchEnd(e){if(e.preventDefault(),e.stopPropagation(),!mobileDragState.isDragging)return;if(Math.sqrt(Math.pow(mobileDragState.currentX-mobileDragState.startX,2)+Math.pow(mobileDragState.currentY-mobileDragState.startY,2))<10)console.log("Short touch detected, selecting card:",mobileDragState.draggedCard.value+mobileDragState.draggedCard.suit),dragState.originalSelection=null,handleMobileCardSelection(mobileDragState.draggedCard,mobileDragState.startRow,mobileDragState.startCol,!1);else{const e=getCanvasCoordinates({clientX:mobileDragState.currentX,clientY:mobileDragState.currentY}),t=pixelToHex(e.x,e.y);let a=!1;if(t&&isValidHex(t.row,t.col)){t.row===mobileDragState.startRow&&t.col===mobileDragState.startCol?(dragState.originalSelection=null,handleMobileCardSelection(mobileDragState.draggedCard,mobileDragState.startRow,mobileDragState.startCol,!1)):(a=processBoardCardDrag(mobileDragState.draggedCard,mobileDragState.startRow,mobileDragState.startCol,t.row,t.col),a&&autoSelectCardAfterDragAction(mobileDragState.draggedCard,t.row,t.col))}a||!t||!isValidHex(t.row,t.col)||t.row===mobileDragState.startRow&&t.col===mobileDragState.startCol||(dragState.originalSelection=null,handleMobileCardSelection(mobileDragState.draggedCard,mobileDragState.startRow,mobileDragState.startCol,!1))}mobileDragState.isDragging=!1,mobileDragState.draggedCard=null,dragState.isDragging=!1,dragState.dragType=null,dragState.draggedCard=null,gameState.selectedCard||gameState.selectedCards&&0!==gameState.selectedCards.length?(hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,dragState.originalSelection=null):clearDragHighlights(),updateCanvas()}function handleBoardCardSelection(e,t,a){const o=selectedCards.findIndex(o=>o.card.id===e.id&&o.row===t&&o.col===a);o>=0?selectedCards.splice(o,1):selectedCards.push({card:e,row:t,col:a}),updateCanvas()}function processBoardCardDrag(e,t,a,o,r){const n={row:t,col:a},s={row:o,col:r};if(gameState.board[o][r]){const l=gameState.board[o][r];if(l.owner!==gameState.currentPlayer&&canAttackCard(e,n,l,s))return saveStateToHistory(),attack(t,a,o,r),clearDragHighlights(),clearSelection(),updateCanvas(),!0}else if(canMoveCard(e,n,s)){saveStateToHistory(),moveCard(t,a,o,r),clearDragHighlights();const n=getValidAttacks(e,o,r);return n.length>0?(gameState.selectedCard=e,gameState.selectedHex=[o,r],gameState.validMoves=[],gameState.validAttacks=n,gameState.blockedMoves=getBlockedMoves(e,o,r),gameState.absorptions=getAbsorptions(e,o,r)):clearSelection(),updateCanvas(),!0}return showInvalidActionFeedback(),!1}function showInvalidActionFeedback(){console.log("Invalid action")}function autoSelectCardAfterDragAction(e,t,a){const o=findCardPosition(e);if(!o)return;const[r,n]=o;if(isCardExhausted(e))return;const s=!gameState.cardsMovedThisTurn.has(e.id)&&getValidMoves(e,r,n).length>0,l=!gameState.cardsAttackedThisTurn.has(e.id)&&getValidAttacks(e,r,n).length>0;(s||l)&&setTimeout(()=>{clearSelection(),selectCard(e,r,n),console.log(`Auto-selected ${e.value}${e.suit} for additional actions`)},200)}function showValidMovesAndAttacks(e,t,a){gameState.validMoves=[],gameState.validAttacks=[],gameState.blockedMoves=[],gameState.absorptions=[],hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,dragState.originalSelection||(dragState.originalSelection={selectedCard:gameState.selectedCard,selectedHex:gameState.selectedHex,selectedCards:[...gameState.selectedCards||[]]}),gameState.selectedCard=e,gameState.selectedHex=[t,a],gameState.validMoves=getValidMoves(e,t,a),gameState.validAttacks=getValidAttacks(e,t,a),gameState.blockedMoves=getBlockedMoves(e,t,a),gameState.absorptions=getAbsorptions(e,t,a),updateCanvas()}function showValidSummonPositions(e){if(gameState.validMoves=[],gameState.validAttacks=[],gameState.blockedMoves=[],gameState.absorptions=[],hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,"setup"===gameState.phase)for(let t=0;t<gameState.board.length;t++)for(let a=0;a<gameState.board[t].length;a++)isValidHex(t,a)&&canSummonCard(e,t,a)&&gameState.validMoves.push([t,a]);else{const e=findLeaderPosition(gameState.currentPlayer);if(e&&!gameState.leaderAttackedThisTurn){const t=countCardsOnMap(gameState.currentPlayer),a=t.leaderCount>=1&&t.regularCards>=5,o=getHexNeighbors(e[0],e[1]);a?(gameState.validMoves=o.filter(([e,t])=>{const a=gameState.board[e][t];return a&&a.owner===gameState.currentPlayer}),validDiscards=[...gameState.validMoves]):(gameState.validMoves=o.filter(([e,t])=>{const a=gameState.board[e][t];return!a||a.owner===gameState.currentPlayer}),validDiscards=o.filter(([e,t])=>{const a=gameState.board[e][t];return a&&a.owner===gameState.currentPlayer}))}}updateCanvas()}function updateDragHoverPreview(e,t,a,o,r){const n=getCanvasCoordinates({clientX:e,clientY:t}),s=pixelToHex(n.x,n.y);if(!s||!isValidHex(s.row,s.col))return hoveredHex=null,hoveredAttackTarget=null,void(attackPreviewResults=null);hoveredHex=[s.row,s.col];const l=gameState.board[s.row][s.col];l?l.owner!==a.owner&&gameState.validAttacks&&gameState.validAttacks.some(([e,t])=>e===s.row&&t===s.col)?(hoveredAttackTarget=[s.row,s.col],attackPreviewResults=calculateAttackPreview([{card:a,row:o,col:r}],s.row,s.col)):(hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null):gameState.validMoves&&gameState.validMoves.some(([e,t])=>e===s.row&&t===s.col)?(hoveredAttackTarget=null,attackPreviewResults=null):hoveredHex=null}function updateHandDragHoverPreview(e,t,a){const o=getCanvasCoordinates({clientX:e,clientY:t}),r=pixelToHex(o.x,o.y);hoveredHex=r&&isValidHex(r.row,r.col)&&gameState.validMoves&&gameState.validMoves.some(([e,t])=>e===r.row&&t===r.col)?[r.row,r.col]:null}function clearDragHighlights(){dragState.originalSelection&&(gameState.selectedCard=dragState.originalSelection.selectedCard,gameState.selectedHex=dragState.originalSelection.selectedHex,gameState.selectedCards=dragState.originalSelection.selectedCards,dragState.originalSelection=null),gameState.validMoves=[],gameState.validAttacks=[],gameState.blockedMoves=[],gameState.absorptions=[],hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null}function calculateAttackPreview(e,t,a){const o=gameState.board[t][a];if(!o)return null;if(o.faceDown&&o.owner!==gameState.currentPlayer)return null;let r=e.map(e=>e.card),n=r.reduce((e,t)=>e+t.attack,0);const s=e[0],l=findSpadeAbsorber(s.row,s.col,t,a,o.owner)||o,d={targetCaptured:!1,attackersCasualites:[],survivingAttackers:[],actualDefender:l,totalAttack:n,isLeaderAttack:!1,captureTokensAdded:0};if("joker"===l.suit)d.isLeaderAttack=!0,d.captureTokensAdded=3,d.targetCaptured=!1,d.survivingAttackers=[...r];else if(n>=l.defense){d.targetCaptured=!0,d.captureTokensAdded=1;const e=l.attack;r.forEach(t=>{t.defense<=e?d.attackersCasualites.push(t):d.survivingAttackers.push(t)})}else{d.targetCaptured=!1,d.captureTokensAdded=0;const e=l.attack;r.forEach(t=>{t.defense<=e?d.attackersCasualites.push(t):d.survivingAttackers.push(t)})}return d}let handDesktopDragState={isDragging:!1,draggedCard:null,startX:0,startY:0,currentX:0,currentY:0,cardElement:null};function handleHandCardMouseStart(e,t){e.preventDefault(),e.stopPropagation(),handDesktopDragState.isDragging=!0,handDesktopDragState.draggedCard=t,handDesktopDragState.startX=e.clientX,handDesktopDragState.startY=e.clientY,handDesktopDragState.currentX=e.clientX,handDesktopDragState.currentY=e.clientY,handDesktopDragState.cardElement=e.target,dragState.isDragging=!0,dragState.dragType="hand-summon",dragState.draggedCard=t,dragState.startX=e.clientX,dragState.startY=e.clientY,lastMousePos={x:e.clientX,y:e.clientY},showValidSummonPositions(handDesktopDragState.draggedCard),document.body.style.cursor="grabbing",document.addEventListener("mousemove",handleHandCardMouseMove),document.addEventListener("mouseup",handleHandCardMouseEnd),requestDragUpdate()}function handleHandCardMouseMove(e){e.preventDefault(),e.stopPropagation(),handDesktopDragState.isDragging&&(handDesktopDragState.currentX=e.clientX,handDesktopDragState.currentY=e.clientY,lastMousePos={x:e.clientX,y:e.clientY},updateHandDragHoverPreview(e.clientX,e.clientY,handDesktopDragState.draggedCard),requestDragUpdate())}function handleHandCardMouseEnd(e){if(e.preventDefault(),e.stopPropagation(),!handDesktopDragState.isDragging)return;document.removeEventListener("mousemove",handleHandCardMouseMove),document.removeEventListener("mouseup",handleHandCardMouseEnd),document.body.style.cursor="";if(Math.sqrt(Math.pow(handDesktopDragState.currentX-handDesktopDragState.startX,2)+Math.pow(handDesktopDragState.currentY-handDesktopDragState.startY,2))<10)handleCardClick(handDesktopDragState.draggedCard);else{const e=getCanvasCoordinates({clientX:handDesktopDragState.currentX,clientY:handDesktopDragState.currentY}),t=pixelToHex(e.x,e.y);t&&isValidHex(t.row,t.col)&&processHandCardDrag(handDesktopDragState.draggedCard,t.row,t.col)}handDesktopDragState.isDragging=!1,handDesktopDragState.draggedCard=null,handDesktopDragState.cardElement=null,dragState.isDragging=!1,dragState.dragType=null,dragState.draggedCard=null,clearDragHighlights(),updateCanvas()}let handMobileDragState={isDragging:!1,draggedCard:null,startX:0,startY:0,currentX:0,currentY:0,cardElement:null};function handleHandCardTouchStart(e,t){if(e.preventDefault(),e.stopPropagation(),1!==e.touches.length)return;const a=e.touches[0];navigator.vibrate&&navigator.vibrate(50),handMobileDragState.isDragging=!0,handMobileDragState.draggedCard=t,handMobileDragState.startX=a.clientX,handMobileDragState.startY=a.clientY,handMobileDragState.currentX=a.clientX,handMobileDragState.currentY=a.clientY,handMobileDragState.cardElement=e.target,dragState.isDragging=!0,dragState.dragType="hand-summon",dragState.draggedCard=t,dragState.startX=a.clientX,dragState.startY=a.clientY,lastMousePos={x:a.clientX,y:a.clientY},showValidSummonPositions(handMobileDragState.draggedCard),requestDragUpdate()}function handleHandCardTouchMove(e){if(e.preventDefault(),e.stopPropagation(),!handMobileDragState.isDragging||1!==e.touches.length)return;const t=e.touches[0];handMobileDragState.currentX=t.clientX,handMobileDragState.currentY=t.clientY,lastMousePos={x:t.clientX,y:t.clientY},updateHandDragHoverPreview(t.clientX,t.clientY,handMobileDragState.draggedCard),requestDragUpdate()}function handleHandCardTouchEnd(e){if(e.preventDefault(),e.stopPropagation(),!handMobileDragState.isDragging)return;if(Math.sqrt(Math.pow(handMobileDragState.currentX-handMobileDragState.startX,2)+Math.pow(handMobileDragState.currentY-handMobileDragState.startY,2))<10)handleCardClick(handMobileDragState.draggedCard);else{const e=getCanvasCoordinates({clientX:handMobileDragState.currentX,clientY:handMobileDragState.currentY}),t=pixelToHex(e.x,e.y);t&&isValidHex(t.row,t.col)&&processHandCardDrag(handMobileDragState.draggedCard,t.row,t.col)}handMobileDragState.isDragging=!1,handMobileDragState.draggedCard=null,handMobileDragState.cardElement=null,dragState.isDragging=!1,dragState.dragType=null,dragState.draggedCard=null,clearDragHighlights(),updateCanvas()}function processHandCardDrag(e,t,a){canSummonCard(e,t,a)?(gameState.selectedCard=e,handleHexClick(t,a)):showInvalidActionFeedback()}function canMoveCard(e,t,a){if(!e||!t||!a)return!1;const{row:o,col:r}=t,{row:n,col:s}=a;if(!isValidHex(n,s))return!1;if(gameState.board[n][s])return!1;return getValidMoves(e,o,r).some(([e,t])=>e===n&&t===s)}function canAttackCard(e,t,a,o){if(!(e&&t&&a&&o))return!1;const{row:r,col:n}=t,{row:s,col:l}=o;if(e.owner===a.owner)return!1;if(!isValidHex(s,l))return!1;if(!gameState.board[s][l])return!1;return getValidAttacks(e,r,n).some(([e,t])=>e===s&&t===l)}function canSummonAtPosition(e,t,a){if(!isValidHex(t,a))return!1;const o=findLeaderPosition(gameState.currentPlayer);if(!o)return!1;const[r,n]=o;if(!getHexNeighbors(r,n).some(([e,o])=>e===t&&o===a))return!1;if(gameState.leaderAttackedThisTurn)return!1;const s=gameState.board[t][a];return!s||s.owner===gameState.currentPlayer}function isValidSetupPosition(e,t,a){if(!isValidHex(e,t))return!1;const o=gameState.board.length,r=o>>1;if(e<(1===a?0:r+1)||e>(1===a?r:o-1))return!1;const n=gameState.board[e][t];return!n||n.owner===a}function canSummonCard(e,t,a){return!!isValidHex(t,a)&&("setup"===gameState.phase?isValidSetupPosition(t,a,gameState.currentPlayer):canSummonAtPosition(e,t,a))}function handleBoardCardDrop(e,t,a){const[,o,r,n]=a.split(":"),s=draggedCard;console.log(`Dropping board card ${s.value}${s.suit} at (${t.row},${t.col})`);const l=gameState.board[t.row][t.col];l&&l.owner!==s.owner&&gameState.validAttacks&&gameState.validAttacks.some(([e,a])=>e===t.row&&a===t.col)?performAttack(t.row,t.col):gameState.validMoves&&gameState.validMoves.some(([e,a])=>e===t.row&&a===t.col)?moveCard(parseInt(r),parseInt(n),t.row,t.col,s):console.log("Invalid drop target for board card")}function requestDragUpdate(){dragUpdateRequested||(dragUpdateRequested=!0,requestAnimationFrame(()=>{updateCanvas(),dragUpdateRequested=!1}))}function startHandCardDrag(e,t,a){dragState.isDragging=!0,dragState.dragType="hand-summon",dragState.draggedCard=e,dragState.startX=t,dragState.startY=a,isDraggingCard=!0,draggedCard=e,console.log(`Started hand drag with ${e.value}${e.suit}`)}function handleHandSummonDragEnd(e){const t=dragState.draggedCard;gameState.validMoves&&gameState.validMoves.some(([t,a])=>t===e.row&&a===e.col)?placeCard(t,e.row,e.col):console.log("Invalid summoning position")}function updateCursor(e,t){const a=document.getElementById("hex-canvas");a.className=a.className.replace(/\bcursor-\w+\b/g,""),a.className=a.className.replace(/\bcan-\w+\b/g,""),a.className=a.className.replace(/\bblocked\b/g,""),a.className=a.className.replace(/\bdragging\b/g,"");let o="default";if(isDraggingMap||isDraggingCard)a.classList.add("dragging"),o="grabbing";else if(null===e||null===t)a.classList.add("cursor-default"),o="default";else{const r=gameState.board[e][t];if("setup"===gameState.phase)gameState.selectedCard?(a.classList.add("can-place"),o="copy"):r&&r.owner===gameState.currentPlayer?(a.classList.add("can-select"),o="pointer"):(a.classList.add("cursor-default"),o="default");else if("play"===gameState.phase){const n=gameState.validMoves&&gameState.validMoves.some(([a,o])=>a===e&&o===t),s=gameState.validAttacks&&gameState.validAttacks.some(([a,o])=>a===e&&o===t);gameState.blockedMoves&&gameState.blockedMoves.some(([a,o])=>a===e&&o===t);s?(a.classList.add("can-attack"),o="crosshair"):n?(a.classList.add("can-move"),o="move"):r&&r.owner===gameState.currentPlayer&&!isCardExhausted(r)?(a.classList.add("can-select"),o="pointer"):r&&r.owner!==gameState.currentPlayer?(a.classList.add("cursor-help"),o="help"):(a.classList.add("cursor-default"),o="default")}else a.classList.add("cursor-default"),o="default"}a.style.cursor=o}function handleCanvasClick(e){if(dragState.isDragging)return;const t=getCanvasCoordinates(e),a=pixelToHex(t.x,t.y);a&&handleHexClick(a.row,a.col,e.ctrlKey)}function drawCards(e,t){const a=gameState.players[e];for(let e=0;e<t&&a.deck.length>0;e++){const e=a.deck.pop();a.hand.push(e)}}function createCardElement(e,t=!1){const a=document.createElement("div");if(a.className=`card ${e.suit} player${e.owner}`,a.dataset.cardId=e.id,a.draggable=!0,a.style.backgroundColor="transparent",a.style.color="white",t||e.faceDown)a.classList.add("face-down"),a.style.backgroundColor="#4a4a4a",a.innerHTML="?";else if("joker"===e.suit)a.innerHTML='<div class="card-value">G</div>';else{const t=getPlayerColor(e),o=getSuitColor(e.suit,e);a.innerHTML=`\n                <div class="card-value" style="color: ${t};">${e.value}</div>\n                <div class="card-suit" style="color: ${o};">${suitSymbols[e.suit]}</div>\n            `}isCardExhausted(e)&&a.classList.add("rotated"),isTouchDevice?(a.addEventListener("touchstart",t=>handleHandCardTouchStart(t,e),{passive:!1}),a.addEventListener("touchmove",handleHandCardTouchMove,{passive:!1}),a.addEventListener("touchend",handleHandCardTouchEnd,{passive:!1})):(a.addEventListener("mousedown",t=>handleHandCardMouseStart(t,e)),a.addEventListener("mousemove",handleHandCardMouseMove),a.addEventListener("mouseup",handleHandCardMouseEnd),a.draggable=!1),a.addEventListener("click",()=>handleCardClick(e));const o=document.createElement("div");return o.className="card-info",o.innerHTML=getCardAbilityText(e),a.appendChild(o),a}function getCardAbilityText(e){let t=[];return"hearts"===e.suit?t.push("Can attack 2 hexes away (blockable)"):"diamonds"===e.suit?t.push("Can jump 2 hexes over other cards"):"spades"===e.suit?t.push("Absorbs attacks on adjacent allies when straight"):"clubs"===e.suit?t.push("Blocks enemy movement in 6 adjacent hexes"):"joker"===e.suit&&t.push("Leader: Can summon 1 card per turn"),t.join(", ")||"Standard movement and attack"}function handleHexClick(e,t,a=!1){"setup"===gameState.phase?handleSetupClick(e,t):"play"===gameState.phase&&handlePlayClick(e,t,a)}function handleSetupClick(e,t){if("place-cards"===gameState.setupStep&&gameState.selectedCard){const a=gameState.selectedCard,o=gameState.currentPlayer,r="joker"===a.suit,n=gameState.setupLeaderPlaced[o],s=gameState.setupCardsPlaced[o];if(r&&n)return void console.log("Cannot place more than 1 Leader");if(!r&&s-(n?1:0)>=5)return void console.log("Cannot place more than 5 regular cards");if(s>=6)return void console.log("Cannot place more than 6 total cards (1 Leader + 5 regular)");if(gameState.board[e][t]&&gameState.board[e][t].owner===gameState.currentPlayer){const a=gameState.board[e][t];gameState.players[gameState.currentPlayer].hand.push(a)}"joker"!==a.suit&&(a.faceDown=!0,console.log(`Setup card ${a.value}${a.suit} placed face down`)),gameState.board[e][t]=a,gameState.players[gameState.currentPlayer].hand=gameState.players[gameState.currentPlayer].hand.filter(e=>e.id!==a.id),gameState.setupCardsPlaced[gameState.currentPlayer]++;const l="joker"===a.suit;l&&(gameState.players[gameState.currentPlayer].leaderPosition=[e,t],gameState.setupLeaderPlaced[gameState.currentPlayer]=!0),clearSelection();const d=gameState.setupLeaderPlaced[1]&&gameState.setupCardsPlaced[1]>=6,i=gameState.setupLeaderPlaced[2]&&gameState.setupCardsPlaced[2]>=6;d&&i?(console.log("Phase transition: Setup -> Play"),gameState.phase="play",gameState.currentPlayer=determineFirstPlayer(),console.log(`First player determined: ${gameState.currentPlayer}, AI enabled: ${aiEnabled[gameState.currentPlayer]}`),updateMapRotation(),updateScreenWakeLock(),showBattleCaption(),setTimeout(()=>{showPlayerTurnCaption(gameState.currentPlayer)},2500),startNewTurn()):l?(console.log("Leader placed - ending turn automatically"),endTurn()):endTurn()}updateCanvas(),updateUI(),saveGameState()}function handlePlayClick(e,t,a=!1){const o=gameState.board[e][t];if(isMobileHovering&&clearMobileHover(),o)if(gameState.selectedCard){if(findCardPosition(gameState.selectedCard))o.owner!==gameState.currentPlayer?handleSingleCardPlay(e,t,o):handleMobileCardSelection(o,e,t,a);else if(o.owner===gameState.currentPlayer){gameState.validMoves.some(([a,o])=>a===e&&o===t)?handleHandCardSummoning(e,t):handleMobileCardSelection(o,e,t,a)}else console.log("Cannot summon: Position occupied by enemy card")}else o.owner===gameState.currentPlayer?handleMobileCardSelection(o,e,t,a):gameState.selectedCards&&gameState.selectedCards.length>0&&gameState.validAttacks.some(([a,o])=>a===e&&o===t)&&(saveStateToHistory(),performCombinedAttack(e,t),clearSelection());else if(gameState.selectedCard){findCardPosition(gameState.selectedCard)?handleSingleCardPlay(e,t,null):handleHandCardSummoning(e,t)}else gameState.selectedCards.length,clearSelection();updateCanvas(),updateUI(),saveGameState()}function handleSingleCardPlay(e,t,a){if(gameState.selectedCard){const o=findCardPosition(gameState.selectedCard);if(gameState.validMoves.some(([a,o])=>a===e&&o===t)){saveStateToHistory(),moveCard(o[0],o[1],e,t);const a=getValidAttacks(gameState.selectedCard,e,t);gameState.selectedHex=[e,t],gameState.validMoves=[],gameState.validAttacks=a,gameState.blockedMoves=getBlockedMoves(gameState.selectedCard,e,t),gameState.absorptions=getAbsorptions(gameState.selectedCard,e,t),0===a.length&&clearSelection()}else gameState.validAttacks.some(([a,o])=>a===e&&o===t)?(saveStateToHistory(),attack(o[0],o[1],e,t),clearSelection()):a&&a.owner===gameState.currentPlayer?selectCard(a,e,t):clearSelection()}else a&&a.owner===gameState.currentPlayer&&selectCard(a,e,t)}function handleCardClick(e){if("setup"===gameState.phase&&"place-cards"===gameState.setupStep){if(e.owner===gameState.currentPlayer){gameState.players[gameState.currentPlayer];if(findLeaderPosition(gameState.currentPlayer))gameState.selectedCard=e,updateUI();else{if("joker"!==e.suit)return void console.log("Leader must be placed first before other cards");gameState.selectedCard=e,updateUI()}}}else if("play"===gameState.phase&&e.owner===gameState.currentPlayer){findCardPosition(e)||handleHandCardSelection(e)}else if("setup"===gameState.phase&&"discard"===gameState.setupStep&&e.owner===gameState.currentPlayer){const t=gameState.players[gameState.currentPlayer];if(!protectLeaderFromRemoval(e,"setup discard"))return void console.warn("Leader discard blocked during setup - keeping in hand");t.hand=t.hand.filter(t=>t.id!==e.id),t.discarded.push(e),5===t.hand.length&&(1===gameState.currentPlayer?gameState.currentPlayer=2:(console.log("Phase transition: Setup -> Play (discard complete)"),gameState.phase="play",gameState.currentPlayer=determineFirstPlayer(),console.log(`First player determined: ${gameState.currentPlayer}, AI enabled: ${aiEnabled[gameState.currentPlayer]}`),updateMapRotation(),updateScreenWakeLock(),showBattleCaption(),setTimeout(()=>{showPlayerTurnCaption(gameState.currentPlayer)},2500),startNewTurn())),updateUI(),saveGameState()}}function handleMultiSelection(e,t,a){if(gameState.cardsAttackedThisTurn.has(e.id)||isCardExhausted(e))return;if("joker"===e.suit)return;if(gameState.selectedCard&&gameState.selectedHex&&"joker"!==gameState.selectedCard.suit){gameState.selectedCards.some(e=>e.card.id===gameState.selectedCard.id)||gameState.selectedCards.push({card:gameState.selectedCard,position:gameState.selectedHex})}const o=gameState.selectedCards.findIndex(t=>t.card.id===e.id);o>=0?gameState.selectedCards.splice(o,1):gameState.selectedCards.push({card:e,position:[t,a]}),calculateCombinedAttacks(),gameState.selectedCard=null,gameState.selectedHex=null,gameState.validMoves=[]}function calculateCombinedAttacks(){if(!gameState.selectedCards||0===gameState.selectedCards.length)return gameState.validAttacks=[],void(gameState.absorptions=[]);let e=null,t=null;for(const a of gameState.selectedCards){const o=getValidAttacks(a.card,a.position[0],a.position[1]),r=getAbsorptions(a.card,a.position[0],a.position[1]);null===e?(e=o,t=r):(e=e.filter(([e,t])=>o.some(([a,o])=>e===a&&t===o)),t=t.filter(e=>r.some(t=>e.target[0]===t.target[0]&&e.target[1]===t.target[1])))}gameState.validAttacks=e||[],gameState.absorptions=t||[],console.log("Combined attacks calculated for",gameState.selectedCards.length,"cards:",gameState.validAttacks.length,"common targets")}function handleMobileCardSelection(e,t,a,o=!1){if(console.log("handleMobileCardSelection called:",e.value+e.suit,"at",t,a),"joker"===e.suit)return console.log("Leader clicked - single selection only"),exitMobileMultiSelectMode(),clearSelection(),void selectCard(e,t,a);console.log("Regular card clicked - adding to multi-selection"),isMobileMultiSelectMode=!0,gameState.selectedCard&&(gameState.selectedCard=null,gameState.selectedHex=null,gameState.validMoves=[]);const r=gameState.selectedCards.findIndex(t=>t.card.id===e.id);if(r>=0?(console.log("Removing card from multi-selection:",e.value+e.suit),gameState.selectedCards.splice(r,1)):(console.log("Adding card to multi-selection:",e.value+e.suit),gameState.selectedCards.push({card:e,position:[t,a]})),0===gameState.selectedCards.length)return console.log("No cards left - exiting multi-select mode"),exitMobileMultiSelectMode(),void clearSelection();calculateCombinedAttacks(),console.log("Multi-selection updated, total cards:",gameState.selectedCards.length)}function exitMobileMultiSelectMode(){isMobileMultiSelectMode=!1}function handleHandCardSelection(e){const t=findLeaderPosition(gameState.currentPlayer);if(!t)return void console.log("Cannot select hand card: Leader not on board");if(gameState.leaderAttackedThisTurn)return void console.log("Cannot select hand card: Leader already used this turn");clearSelection(),gameState.selectedCard=e;const a=countCardsOnMap(gameState.currentPlayer),o=a.leaderCount>=1&&a.regularCards>=5,r=getHexNeighbors(t[0],t[1]);o?(gameState.validMoves=r.filter(([e,t])=>{const a=gameState.board[e][t];return a&&a.owner===gameState.currentPlayer}),validDiscards=[...gameState.validMoves]):(gameState.validMoves=r.filter(([e,t])=>{const a=gameState.board[e][t];return!a||a.owner===gameState.currentPlayer}),validDiscards=r.filter(([e,t])=>{const a=gameState.board[e][t];return a&&a.owner===gameState.currentPlayer})),gameState.validAttacks=[],gameState.blockedMoves=[],gameState.absorptions=[],updateCanvas(),updateUI()}function handleHandCardSummoning(e,t){const a=gameState.selectedCard;if(a)if(gameState.validMoves.some(([a,o])=>a===e&&o===t)){const o=gameState.board[e][t];if(o&&o.owner!==gameState.currentPlayer)console.log("Cannot summon: Position occupied by enemy card");else{saveStateToHistory(),o?console.log(`Replacing ${o.value}${o.suit} with ${a.value}${a.suit} via mobile tap`):console.log(`Summoning ${a.value}${a.suit} to empty position via mobile tap`);placeCard(a,e,t)?(gameState.leaderAttackedThisTurn=!0,console.log("Card summoned/replaced successfully via mobile tap"),clearSelection()):console.log("Failed to summon/replace card via mobile tap")}}else console.log("Cannot summon: Invalid summoning position (not adjacent to leader or leader already used)")}function calculateAttackResults(e,t){const a=gameState.board[e][t];if(!a)return null;if(a.faceDown&&a.owner!==gameState.currentPlayer)return null;let o=[],r=0;if(gameState.selectedCards&&gameState.selectedCards.length>0)o=gameState.selectedCards.map(e=>e.card),r=o.reduce((e,t)=>e+t.attack,0);else{if(!gameState.selectedCard)return null;o=[gameState.selectedCard],r=gameState.selectedCard.attack}const n=gameState.selectedCards&&gameState.selectedCards.length>0?gameState.selectedCards[0]:{position:gameState.selectedHex},s=findSpadeAbsorber(n.position[0],n.position[1],e,t,a.owner)||a,l={targetCaptured:!1,attackersCasualites:[],survivingAttackers:[],actualDefender:s,totalAttack:r,isLeaderAttack:!1,captureTokensAdded:0};if("joker"===s.suit)l.isLeaderAttack=!0,l.captureTokensAdded=3,l.targetCaptured=!1,l.survivingAttackers=[...o];else if(r>=s.defense){l.targetCaptured=!0,l.captureTokensAdded=1;const e=s.attack;o.forEach(t=>{t.defense<=e?l.attackersCasualites.push(t):l.survivingAttackers.push(t)})}else{l.targetCaptured=!1,l.captureTokensAdded=0;const e=s.attack;o.forEach(t=>{t.defense<=e?l.attackersCasualites.push(t):l.survivingAttackers.push(t)})}return l}function performCombinedAttack(e,t){const a=gameState.board[e][t];if(!a)return;for(const e of gameState.selectedCards)e.card.faceDown&&(e.card.faceDown=!1,console.log(`Attacker ${e.card.value}${e.card.suit} automatically faced up for combined attack`));a.faceDown&&(a.faceDown=!1,console.log(`Defender ${a.value}${a.suit} automatically faced up for defense`));let o=0;for(const e of gameState.selectedCards)o+=e.card.attack;const r=gameState.selectedCards[0],n=findSpadeAbsorber(r.position[0],r.position[1],e,t,a.owner),s=n||a,l={targetCaptured:o>=s.defense&&"joker"!==s.suit,isLeaderAttack:"joker"===s.suit,attackersCasualites:[],actualDefender:s};if(startAttackAnimation(gameState.selectedCards,[e,t],l),n&&n!==a&&n.faceDown&&(n.faceDown=!1,console.log(`Spade absorber ${n.value}${n.suit} automatically faced up for defense`)),console.log(`Combined attack: ${o} vs ${s.defense}`),"joker"===s.suit){for(let e=0;e<3;e++)gameState.players[gameState.currentPlayer].captured.push({id:`leader_capture_${Math.random()}`,suit:"capture",value:"CAPTURE",owner:s.owner});gameState.leaderAttackedThisTurn=!0,startLeaderAttackAnimation(s,[e,t]);for(const e of gameState.selectedCards)"joker"===e.card.suit?(console.warn("Leader in combined attack against leader - leader survives but gets exhausted"),gameState.cardsAttackedThisTurn.add(e.card.id),gameState.cardsMovedThisTurn.add(e.card.id)):(gameState.players[gameState.currentPlayer].discarded.push(e.card),startFadeOutAnimation(e.card,e.position,"discarded",!0),console.log(`Card ${e.card.suit} ${e.card.value} discarded after combined attack on enemy leader`))}else{const r=o>=s.defense,l=s.attack;if(r){if(!protectLeaderFromRemoval(s,"combined attack capture"))return void console.warn("Leader capture blocked - leaders are immortal!");if(gameState.players[gameState.currentPlayer].captured.push(s),"joker"===s.suit)return void console.error("CRITICAL ERROR: Attempted to remove leader from board! This should never happen!");if(n){const e=findCardPosition(s);if("joker"===n.suit)return void console.error("CRITICAL ERROR: Attempted to remove absorbing leader! This should never happen!");setTimeout(()=>{startFadeOutAnimation(s,e,"captured",!0)},400)}else{if("joker"===a.suit)return void console.error("CRITICAL ERROR: Attempted to remove leader from board in combined attack! This should never happen!");setTimeout(()=>{startFadeOutAnimation(a,[e,t],"captured",!0)},400)}}else"joker"!==s.suit&&(gameState.cardsAttackedThisTurn.add(s.id),gameState.cardsMovedThisTurn.add(s.id));for(const e of gameState.selectedCards){const t=e.card;l>=t.defense?"joker"===t.suit?(console.warn("Leader would be destroyed by counter-attack, but leaders are immortal!"),gameState.cardsAttackedThisTurn.add(t.id),gameState.cardsMovedThisTurn.add(t.id)):(gameState.players[gameState.currentPlayer].discarded.push(t),startFadeOutAnimation(t,e.position,"discarded",!0)):(gameState.cardsAttackedThisTurn.add(t.id),gameState.cardsMovedThisTurn.add(t.id))}}const d=gameState.turn+2;for(const e of gameState.selectedCards)gameState.cardsAttackExhaustion.set(e.card.id,d);s&&"joker"!==s.suit&&gameState.cardsAttackExhaustion.set(s.id,d),updateBoardCardOverlays(),"play"===gameState.phase&&validateLeadersOnMap(),checkWinCondition()}function isCardExhausted(e){const t=gameState.cardsMovedThisTurn.has(e.id),a=gameState.cardsAttackedThisTurn.has(e.id),o=gameState.cardsAttackExhaustion.get(e.id),r=o&&gameState.turn<=o;return t&&a||r}function selectCard(e,t,a){console.log("selectCard called for:",e.value+e.suit,"owner:",e.owner,"currentPlayer:",gameState.currentPlayer,"exhausted:",isCardExhausted(e)),e.owner!==gameState.currentPlayer||isCardExhausted(e)?console.log("Selection blocked - wrong owner or exhausted"):(console.log("Setting selectedCard to:",e.value+e.suit),gameState.validMoves=[],gameState.validAttacks=[],gameState.blockedMoves=[],gameState.absorptions=[],hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,gameState.selectedCard=e,gameState.selectedHex=[t,a],gameState.validMoves=getValidMoves(e,t,a),gameState.validAttacks=getValidAttacks(e,t,a),gameState.blockedMoves=getBlockedMoves(e,t,a),gameState.absorptions=getAbsorptions(e,t,a),console.log("selectCard calculated - validAttacks:",gameState.validAttacks.length,"targets"),updateCanvas(),hoveredHex&&updateCursor(hoveredHex[0],hoveredHex[1]))}function clearSelection(){gameState.selectedCard=null,gameState.selectedHex=null,gameState.selectedCards=[],gameState.validMoves=[],gameState.validAttacks=[],gameState.blockedMoves=[],gameState.absorptions=[],validDiscards=[],isMobileHovering&&clearMobileHover(),exitMobileMultiSelectMode(),hoveredHex&&updateCursor(hoveredHex[0],hoveredHex[1])}function getSuitSymbol(e){switch(e){case"hearts":return"â™¥";case"diamonds":return"â™¦";case"clubs":return"â™£";case"spades":return"â™ ";case"joker":return"â˜…";default:return""}}function getValidMoves(e,t,a){const o=[];if(isCardExhausted(e))return o;if(gameState.cardsMovedThisTurn.has(e.id))return o;const r=gameState.selectedCard===e||gameState.selectedCards&&gameState.selectedCards.some(t=>t.card===e),n=aiEnabled[e.owner],s=e.faceDown&&!r&&!n;if(e.faceDown&&n&&!r&&console.log(`[AI DEBUG] Calculating moves for AI face-down card ${e.value}${e.suit} at [${t},${a}]`),s){const e=getHexNeighbors(t,a);for(const[t,a]of e){gameState.board[t][a]||o.push([t,a])}return o}if("diamonds"===e.suit){const r=getHexNeighbors(t,a);for(const[n,s]of r){const r=getHexNeighbors(n,s);for(const[l,d]of r)if(l!==t||d!==a){if(!gameState.board[l][d]){const r=isBlockedByClubs(e,t,a,n,s),i=isBlockedByClubs(e,n,s,l,d);r||i||o.push([l,d])}}}}else{const r=getHexNeighbors(t,a);for(const[n,s]of r){gameState.board[n][s]||isBlockedByClubs(e,t,a,n,s)||o.push([n,s])}}return o}function getBlockedMoves(e,t,a){const o=[];if(gameState.cardsMovedThisTurn.has(e.id))return o;if("diamonds"===e.suit){const r=new Map,n=getHexNeighbors(t,a);for(const[o,s]of n){const n=getHexNeighbors(o,s);for(const[l,d]of n)if(l!==t||d!==a){if(!gameState.board[l][d]){const n=`${l},${d}`,i=isBlockedByClubs(e,t,a,o,s),c=isBlockedByClubs(e,o,s,l,d),u=i||c;r.has(n)||r.set(n,[]),r.get(n).push(u)}}}for(const[e,t]of r)if(t.every(e=>e)){const[t,a]=e.split(",").map(Number);o.push([t,a])}}else{const r=getHexNeighbors(t,a);for(const[n,s]of r){!gameState.board[n][s]&&isBlockedByClubs(e,t,a,n,s)&&o.push([n,s])}}return o}function getValidAttacks(e,t,a){const o=[];if(isCardExhausted(e))return o;if(gameState.cardsAttackedThisTurn.has(e.id))return o;const r=gameState.selectedCard===e||gameState.selectedCards&&gameState.selectedCards.some(t=>t.card===e),n=aiEnabled[e.owner];if(e.faceDown&&!r&&!n)return o;if(e.faceDown&&n&&!r&&console.log(`[AI DEBUG] Calculating attacks for AI face-down card ${e.value}${e.suit} at [${t},${a}]`),"joker"===e.suit)return o;if("hearts"===e.suit){const r=Array.from({length:11},()=>Array(11).fill(!1)),n=[[t,a,0]];for(r[t][a]=!0;n.length>0;){const[t,a,s]=n.shift();if(s>0&&s<=2){const r=gameState.board[t][a];if(r&&r.owner!==e.owner){o.push([t,a]);continue}}if(s<2)for(const[l,d]of getHexNeighbors(t,a)){if(!isValidHex(l,d)||r[l][d])continue;const t=gameState.board[l][d];t&&t.owner!==e.owner?t.owner!==e.owner&&s+1<=2&&(o.push([l,d]),r[l][d]=!0):(n.push([l,d,s+1]),r[l][d]=!0)}}}else{const r=getHexNeighbors(t,a);for(const[t,a]of r){const r=gameState.board[t][a];if(r){if(r.owner===e.owner){console.log("Skipping friendly target");continue}o.push([t,a])}}}return o}function getAbsorptions(e,t,a){const o=[],r=getValidAttacks(e,t,a);for(const[e,n]of r){const r=gameState.board[e][n];if(r){const s=findSpadeAbsorber(t,a,e,n,r.owner);if(s){const t=findCardPosition(s);o.push({target:[e,n],absorber:t})}}}return o}function isBlockedByClubs(e,t,a,o,r){for(let t=0;t<11;t++)for(let a=0;a<11;a++){const n=gameState.board[t][a];if(n&&n.owner!==e.owner&&!isCardExhausted(n)&&!n.faceDown&&"clubs"===n.suit){if(getHexNeighbors(t,a).some(([e,t])=>e===o&&t===r))return!0}}return!1}function isAttackBlocked(e,t,a,o){const r=o-t,n=a-e,s=getDistance(e,t,a,o);if(s<=1)return!1;for(let a=1;a<s;a++){const o=e+Math.round(n*a/s),l=t+Math.round(r*a/s);if(gameState.board[o]&&gameState.board[o][l])return!0}return!1}function moveCard(e,t,a,o){const r=gameState.board[e][t];if(isCardExhausted(r))return console.error("CRITICAL ERROR: Attempted to move exhausted card! This should never happen!"),void console.error("Movement blocked to maintain game integrity");if(gameState.board[a][o]&&"joker"===gameState.board[a][o].suit)return console.error("CRITICAL ERROR: Attempted to move onto leader position! This should never happen!"),void console.error("Movement blocked to protect leader integrity");if(gameState.board[e][t]=null,gameState.board[a][o]=r,r.faceDown&&"diamonds"===r.suit){2===getDistance(e,t,a,o)&&(r.faceDown=!1,console.log(`Face down diamond ${r.value}â™¦ automatically faced up after moving 2 steps`))}gameState.cardsMovedThisTurn.add(r.id);const n=getValidAttacks(r,a,o),s=n.length>0,l="joker"===r.suit,d=gameState.leaderAttackedThisTurn;let i=!1;i=l?d:!s,i?(gameState.cardsAttackedThisTurn.add(r.id),console.log(`Card ${r.value}${r.suit} marked as exhausted after move (leader: ${l}, summoned: ${d}, no targets: ${!s})`)):(console.log(`Auto-selecting ${r.value}${r.suit} after movement (has ${n.length} attacks available)`),gameState.selectedCard=r,gameState.selectedHex=[a,o],gameState.validMoves=[],gameState.validAttacks=n,gameState.blockedMoves=getBlockedMoves(r,a,o),gameState.absorptions=getAbsorptions(r,a,o)),updateBoardCardOverlays(),updateCanvas()}function attack(e,t,a,o){const r=gameState.board[e][t],n=gameState.board[a][o];if(!n)return;if(isCardExhausted(r))return console.error("CRITICAL ERROR: Attempted to attack with exhausted card! This should never happen!"),void console.error("Attack blocked to maintain game integrity");if(n.owner===r.owner)return void console.warn("Attempted friendly fire prevented:",r,"trying to attack",n);r.faceDown&&(r.faceDown=!1,console.log(`Attacker ${r.value}${r.suit} automatically faced up for attack`)),n.faceDown&&(n.faceDown=!1,console.log(`Defender ${n.value}${n.suit} automatically faced up for attack`));const s=findSpadeAbsorber(e,t,a,o,n.owner),l=s||n,d={targetCaptured:r.attack>=l.defense&&"joker"!==l.suit,isLeaderAttack:"joker"===l.suit,attackersCasualites:l.attack>=r.defense&&"joker"!==r.suit?[r]:[],actualDefender:l};startAttackAnimation([{card:r,position:[e,t]}],[a,o],d),s&&s.faceDown&&(s.faceDown=!1,console.log(`Absorber ${s.value}${s.suit} automatically faced up for absorption`));let i=r.attack;if("joker"===l.suit){for(let e=0;e<3;e++)gameState.players[r.owner].captured.push({id:`leader_capture_${Math.random()}`,suit:"capture",value:"CAPTURE",owner:l.owner});gameState.leaderAttackedThisTurn=!0,startLeaderAttackAnimation(l,[a,o]),"joker"===r.suit?(console.warn("Leader attacked leader - leader survives but gets exhausted (cannot be discarded)"),gameState.cardsAttackedThisTurn.add(r.id),gameState.cardsMovedThisTurn.add(r.id)):(gameState.players[r.owner].discarded.push(r),startFadeOutAnimation(r,[e,t],"discarded",!0),console.log(`Card ${r.suit} ${r.value} discarded after attacking enemy leader`))}else{const d=i>=l.defense,c=l.attack>=r.defense;if(d){if(!protectLeaderFromRemoval(l,"single attack capture"))return void console.warn("Leader capture blocked - leaders are immortal!");if(gameState.players[r.owner].captured.push(l),"joker"===l.suit)return void console.error("CRITICAL ERROR: Attempted to remove leader from board! This should never happen!");if(s){const e=findCardPosition(l);if("joker"===s.suit)return void console.error("CRITICAL ERROR: Attempted to remove absorbing leader! This should never happen!");setTimeout(()=>{startFadeOutAnimation(l,e,"captured",!0)},1400)}else{if("joker"===n.suit)return void console.error("CRITICAL ERROR: Attempted to remove leader from board in single attack! This should never happen!");setTimeout(()=>{startFadeOutAnimation(n,[a,o],"captured",!0)},1400)}}else"joker"!==l.suit&&(gameState.cardsAttackedThisTurn.add(l.id),gameState.cardsMovedThisTurn.add(l.id));c?"joker"===r.suit?(console.warn("Leader would be destroyed by counter-attack, but leaders are immortal!"),gameState.cardsAttackedThisTurn.add(r.id),gameState.cardsMovedThisTurn.add(r.id)):(gameState.players[r.owner].discarded.push(r),startFadeOutAnimation(r,[e,t],"discarded",!0)):(gameState.cardsAttackedThisTurn.add(r.id),gameState.cardsMovedThisTurn.add(r.id))}gameState.cardsAttackedThisTurn.add(r.id);const c=gameState.turn+2;gameState.cardsAttackExhaustion.set(r.id,c),l&&"joker"!==l.suit&&gameState.cardsAttackExhaustion.set(l.id,c),updateBoardCardOverlays(),"play"===gameState.phase&&validateLeadersOnMap(),gameState.players[r.owner].captured.length>=10&&(gameState.phase="end",updateScreenWakeLock(),showPlayerWinCaption(r.owner),setTimeout(()=>{isBotVsBot()&&(console.log("Bot vs Bot: Auto-restarting new game after 10s."),setTimeout(()=>{resetGame()},1e4))},1e3))}function findSpadeAbsorber(e,t,a,o,r){const n=getHexNeighbors(e,t);for(const[e,t]of n){const a=gameState.board[e][t];if(a&&"spades"===a.suit&&a.owner===r&&!isCardExhausted(a)&&!a.faceDown)return a}const s=getDistance(e,t,a,o);if(s>1){const n=o-t,l=a-e;for(let a=1;a<s;a++){const o=getHexNeighbors(e+Math.round(l*a/s),t+Math.round(n*a/s));for(const[e,t]of o){const a=gameState.board[e][t];if(a&&"spades"===a.suit&&a.owner===r&&!isCardExhausted(a)&&!a.faceDown)return a}}}return null}function findCardPosition(e){for(let t=0;t<11;t++)for(let a=0;a<11;a++)if(gameState.board[t][a]&&gameState.board[t][a].id===e.id)return[t,a];return null}function findLeaderPosition(e){const t=gameState.players[e].leaderPosition;if(t&&gameState.board[t[0]]&&gameState.board[t[0]][t[1]]&&"joker"===gameState.board[t[0]][t[1]].suit&&gameState.board[t[0]][t[1]].owner===e)return t;for(let t=0;t<11;t++)for(let a=0;a<11;a++){const o=gameState.board[t][a];if(o&&"joker"===o.suit&&o.owner===e)return gameState.players[e].leaderPosition=[t,a],[t,a]}return gameState.players[e].leaderPosition=null,null}function autoSelectLeaderForSetup(e){if(aiEnabled[e])return console.log(`Skipping auto-select for AI Player ${e}`),!1;const t=gameState.players[e].hand.find(e=>"joker"===e.suit);return t?(gameState.selectedCard=t,console.log(`Auto-selected leader for human Player ${e}`),updateUI(),!0):(console.log(`No leader found in Player ${e}'s hand`),!1)}function determineFirstPlayer(){let e=0,t=0;for(let a=0;a<11;a++)for(let o=0;o<11;o++)gameState.board[a][o]&&(1===gameState.board[a][o].owner?e++:t++);if(e!==t)return e<t?1:2;const a=gameState.players[1].hand.length,o=gameState.players[2].hand.length;return a!==o?a<o?1:2:1}function startNewTurn(){isMobileHovering&&clearMobileHover(),exitMobileMultiSelectMode();const e=gameState.players[gameState.currentPlayer];for(;e.hand.length<5&&e.deck.length>0;)drawCards(gameState.currentPlayer,1);gameState.cardsMovedThisTurn.clear(),gameState.cardsAttackedThisTurn.clear();for(const[e,t]of gameState.cardsAttackExhaustion.entries())gameState.turn>t&&gameState.cardsAttackExhaustion.delete(e);gameState.leaderAttackedThisTurn=!1,gameHistory=[];const t=`${gameState.currentPlayer}-${gameState.turn}`;aiActionCount.delete(t),updateUI(),updateBoardCardOverlays(),aiEnabled[gameState.currentPlayer]&&"play"===gameState.phase?(console.log(`startNewTurn: Triggering AI for player ${gameState.currentPlayer}`),setTimeout(()=>{performAIMove(gameState.currentPlayer)},300)):console.log(`startNewTurn: NOT triggering AI. Player ${gameState.currentPlayer}, aiEnabled: ${aiEnabled[gameState.currentPlayer]}, phase: ${gameState.phase}`)}function toggleGamePhase(){if(localStorage.setItem("tcg-has-interacted","true"),"setup"===gameState.phase)console.log("Manual phase toggle: Setup -> Play"),gameState.phase="play",gameState.currentPlayer=determineFirstPlayer(),console.log(`First player determined: ${gameState.currentPlayer}, AI enabled: ${aiEnabled[gameState.currentPlayer]}`),updateMapRotation(),showBattleCaption(),setTimeout(()=>{showPlayerTurnCaption(gameState.currentPlayer)},2500),startNewTurn(),console.log("Switched to Play phase");else if("play"===gameState.phase){gameState.phase="setup",gameState.setupStep="place-cards",gameState.selectedCard=null,gameState.selectedHex=null,gameState.selectedCards=[],gameState.validMoves=[],gameState.validAttacks=[],gameState.blockedMoves=[],gameState.absorptions=[],gameState.cardsMovedThisTurn.clear(),gameState.cardsAttackedThisTurn.clear(),gameState.cardsAttackExhaustion.clear(),gameState.leaderAttackedThisTurn=!1,showSetupCaption();findLeaderPosition(gameState.currentPlayer)||autoSelectLeaderForSetup(gameState.currentPlayer),console.log("Switched to Setup phase")}updateUI(),saveGameState(),updateScreenWakeLock();const e=document.getElementById("menu-options");e&&!e.classList.contains("hidden")&&e.classList.add("hidden")}function endTurn(){if(gameState.currentPlayer=1===gameState.currentPlayer?2:1,"play"===gameState.phase)gameState.turn++,gameState.moveCount++,checkAggressorRule(),validateLeadersOnMap(),updateMapRotation(),clearSelection(),showPlayerTurnCaption(gameState.currentPlayer),startNewTurn(),setTimeout(()=>{updateCanvas()},100);else if("setup"===gameState.phase){updateMapRotation(),clearSelection();findLeaderPosition(gameState.currentPlayer)||autoSelectLeaderForSetup(gameState.currentPlayer),updateCanvas(),updateUI(),updateBoardCardOverlays(),aiEnabled[gameState.currentPlayer]&&setTimeout(()=>{performAISetupMove(gameState.currentPlayer)},300)}"play"===gameState.phase&&validateLeadersOnMap(),saveGameState()}function checkAggressorRule(){if(gameState.moveCount>=100){if(gameState.players[1].captured.length!==gameState.players[2].captured.length)return!1;const e=gameState.firstPlayer,t=1===e?2:1,a=`Player ${t} wins! First player (Player ${e}) loses after 100 moves without decisive captures.`;return gameState.phase="end",updateScreenWakeLock(),console.log(`Game ended by 100-move aggressor rule. ${a}`),showPlayerWinCaption(t),setTimeout(()=>{isBotVsBot()&&(console.log("Bot vs Bot: Auto-restarting new game after 10s."),setTimeout(()=>{resetGame()},1e4))},1e3),!0}return!1}function clearAllFadeAnimations(){fadeOutElements.forEach(e=>{e.parentNode&&e.parentNode.removeChild(e)}),fadeOutElements=[]}function updateCanvas(){const e=canvas.logicalWidth||canvas.width,t=canvas.logicalHeight||canvas.height;ctx.clearRect(0,0,e,t);for(let e=0;e<11;e++)for(let t=0;t<11;t++){if(!isValidHex(e,t))continue;const a=hexToPixel(t,e);let o="#3a3a3a",r="#666",n=1;const s=gameState.validMoves.some(([a,o])=>a===e&&o===t),l=gameState.blockedMoves.some(([a,o])=>a===e&&o===t),d=gameState.validAttacks.some(([a,o])=>a===e&&o===t),i=hoveredHex&&gameState.absorptions.some(a=>a.target[0]===hoveredHex[0]&&a.target[1]===hoveredHex[1]&&a.absorber&&a.absorber[0]===e&&a.absorber[1]===t);if(s&&!gameState.board[e][t]){const e=1===gameState.currentPlayer?"#87ceeb":"#ffd700";o=`${e}40`,r=`${e}99`,n=1}l&&(o="#ff000030",r="#ff000060",n=1),drawHexagon(a.x,a.y,o,r,n);const c=gameState.board[e][t];if(c)if(dragState.isDragging&&dragState.draggedCard&&dragState.draggedCard.id===c.id){if(ctx.save(),ctx.globalAlpha=.3,drawHexagon(a.x,a.y,"rgba(200, 200, 200, 0.1)","#999",1),ctx.restore(),attackPreviewResults&&hoveredAttackTarget){attackPreviewResults.attackersCasualites.some(e=>e.id===dragState.draggedCard.id)&&drawSkullSymbol(a.x,a.y)}}else{const o=gameState.selectedHex&&gameState.selectedHex[0]===e&&gameState.selectedHex[1]===t,r=gameState.selectedCards&&gameState.selectedCards.some(a=>a.position[0]===e&&a.position[1]===t),n=d&&gameState.absorptions.some(a=>a.target[0]===e&&a.target[1]===t),s=hoveredHex&&hoveredHex[0]===e&&hoveredHex[1]===t&&n,l=d&&!s,u={...c};if(c.faceDown&&o&&(u.faceDown=!1),drawCard(u,a.x,a.y,l,o,r,i),hoveredHex&&hoveredHex[0]===e&&hoveredHex[1]===t){const o=gameState.absorptions.find(a=>a.target[0]===e&&a.target[1]===t);if(o){o.absorber&&o.absorber[0]===e&&o.absorber[1]===t||drawShieldSymbol(a.x,a.y)}}if(attackPreviewResults&&hoveredAttackTarget){const e=attackPreviewResults.targetCaptured&&attackPreviewResults.actualDefender.id===c.id||attackPreviewResults.attackersCasualites.some(e=>e.id===c.id),t=attackPreviewResults.isLeaderAttack&&attackPreviewResults.actualDefender.id===c.id;e?drawSkullSymbol(a.x,a.y):t&&drawLeaderAttackSymbol(a.x,a.y)}if(draggedCard&&"play"===gameState.phase){if(!findCardPosition(draggedCard)&&c.owner===gameState.currentPlayer){const o=findLeaderPosition(gameState.currentPlayer);if(o&&!gameState.leaderAttackedThisTurn){getHexNeighbors(o[0],o[1]).some(([a,o])=>a===e&&o===t)&&drawDiscardSymbol(a.x,a.y)}}}validDiscards.some(([a,o])=>a===e&&o===t)&&drawDiscardSymbol(a.x,a.y)}!c&&gameState.selectedCard&&gameState.blockedMoves.some(([a,o])=>a===e&&o===t)&&drawBlockedSymbol(a.x,a.y),!hoveredHex||hoveredHex[0]!==e||hoveredHex[1]!==t||c||gameState.selectedCard&&gameState.blockedMoves.some(([a,o])=>a===e&&o===t)||drawCoordinateOnGrid(a.x,a.y,t,e)}dragState.isDragging&&dragState.draggedCard&&drawDraggingCard()}function convertToGrayscale(e){let t,a,o;if(e.startsWith("#")){const r=e.slice(1);if(3===r.length)t=parseInt(r[0]+r[0],16),a=parseInt(r[1]+r[1],16),o=parseInt(r[2]+r[2],16);else{if(6!==r.length)return e;t=parseInt(r.slice(0,2),16),a=parseInt(r.slice(2,4),16),o=parseInt(r.slice(4,6),16)}}else{if(!e.startsWith("rgb"))return"#888888";{const r=e.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);if(!r)return e;t=parseInt(r[1]),a=parseInt(r[2]),o=parseInt(r[3])}}const r=Math.round(.299*t+.587*a+.114*o).toString(16).padStart(2,"0");return`#${r}${r}${r}`}function drawCard(e,t,a,o=!1,r=!1,n=!1,s=!1){let l="#ffffff",d="#ffffff";const i=e.owner===gameState.currentPlayer,c=!aiEnabled[e.owner],u=aiEnabled[1]&&aiEnabled[2],g=!aiEnabled[1]&&!aiEnabled[2],m=isCardExhausted(e);let f=!1;f=g?i:!!u||c,(!e.faceDown||e.faceDown&&f)&&(l=getPlayerColor(e),d=getSuitColor(e.suit,e),m&&(l=convertToGrayscale(l),d=convertToGrayscale(d))),ctx.save(),ctx.globalAlpha=1;let h=(e.faceDown,getPlayerColor(e)),p=2,S=null;if(r)h="#ffffff",p=3;else if(n){h="#ffa500",p=3,S=`rgba(255, 165, 0, ${.3+.2*Math.sin(.003*Date.now())})`}else s&&!e.faceDown?(S="rgba(255, 128, 128, 0.5)",p=3):o&&(S="rgba(255, 0, 0, 0.2)",p=3);const v=.8*hexSize,C=[];for(let e=0;e<6;e++){const o=Math.PI/3*e;C.push({x:t+v*Math.cos(o),y:a+v*Math.sin(o)})}ctx.beginPath(),ctx.moveTo(C[0].x,C[0].y);for(let e=1;e<6;e++)ctx.lineTo(C[e].x,C[e].y);ctx.closePath(),S&&(ctx.fillStyle=S,ctx.fill()),m&&(ctx.globalAlpha=.5),ctx.strokeStyle=h,ctx.lineWidth=p,ctx.stroke(),m&&(ctx.globalAlpha=1),e.faceDown&&f&&drawDiagonalStripes(t,a,v,`${getPlayerColor(e)}20`);(!e.faceDown||f)&&(ctx.textAlign="center",ctx.textBaseline="middle",e.faceDown&&f&&(ctx.globalAlpha*=.5),"joker"===e.suit?(ctx.fillStyle=d,ctx.font=`bold ${Math.round(20*zoomLevel)}px Arial`,ctx.fillText("â™”",t,a+Math.round(2*zoomLevel))):(ctx.fillStyle=l,ctx.font=`bold ${Math.round(14*zoomLevel)}px Arial`,ctx.fillText(e.value,t,a-Math.round(5*zoomLevel)),ctx.fillStyle=d,ctx.font=`bold ${Math.round(16*zoomLevel)}px Arial`,ctx.fillText(suitSymbols[e.suit],t,a+Math.round(6*zoomLevel)))),ctx.restore()}function drawDiagonalStripes(e,t,a,o){ctx.save();const r=[];for(let o=0;o<6;o++){const n=Math.PI/3*o;r.push({x:e+a*Math.cos(n),y:t+a*Math.sin(n)})}ctx.beginPath(),ctx.moveTo(r[0].x,r[0].y);for(let e=1;e<6;e++)ctx.lineTo(r[e].x,r[e].y);ctx.closePath(),ctx.clip(),ctx.strokeStyle=o,ctx.lineWidth=2*zoomLevel;const n=8*zoomLevel,s=Math.ceil(2*a/n)+2;for(let o=-s;o<=s;o++){const r=o*n;ctx.beginPath(),ctx.moveTo(e-a+r,t-a),ctx.lineTo(e+a+r,t+a),ctx.stroke()}ctx.restore()}function drawDraggingCard(){if(!dragState.isDragging||!dragState.draggedCard)return;let e,t;if(lastMousePos){const a=getCanvasCoordinates({clientX:lastMousePos.x,clientY:lastMousePos.y});e=a.x,t=a.y}else if(lastTouchPos){const a=getCanvasCoordinates({clientX:lastTouchPos.x,clientY:lastTouchPos.y});e=a.x,t=a.y}else e=dragState.startX,t=dragState.startY;ctx.save(),ctx.globalAlpha=.8,drawHexagon(e,t,"rgba(100, 100, 100, 0.3)","#fff",2);const a=dragState.draggedCard,o={...a};a.faceDown&&(o.faceDown=!1),drawCard(o,e,t,!1,!0,!1,!1),ctx.restore()}function updateUI(){document.getElementById("current-player").textContent=`Player ${gameState.currentPlayer}`,document.getElementById("game-phase").textContent=gameState.phase.charAt(0).toUpperCase()+gameState.phase.slice(1);let e="";if("setup"===gameState.phase)if("place-cards"===gameState.setupStep){const t=gameState.currentPlayer,a=gameState.setupCardsPlaced[t],o=gameState.setupLeaderPlaced[t],r=a-(o?1:0);e=`Place ${o?"âœ“L":"1L"} + ${Math.max(0,5-r)}R on map (${a}/6)`}else"discard"===gameState.setupStep&&(e="Discard to 5 cards");else if("play"===gameState.phase){if(e=`Turn ${gameState.turn} | Move ${gameState.moveCount}/100`,gameState.moveCount>=80){const t=100-gameState.moveCount,a=gameState.firstPlayer;e+=t>0?` | âš”ï¸ Aggressor (P${a}) loses in ${t} moves!`:" | ðŸ AGGRESSOR RULE TRIGGERED!"}const t=countCardsOnMap(gameState.currentPlayer);if(e+=` | On Map: ${t.leaderCount}L + ${t.regularCards}R (${t.totalCards}/6)`,gameState.selectedCards&&gameState.selectedCards.length>0){const t=gameState.selectedCards.reduce((e,t)=>e+t.card.attack,0);e+=` | ðŸ”¥ MULTI-SELECT: ${gameState.selectedCards.length} cards (${t} power) ðŸ”¥`}else isMobileMultiSelectMode&&(e+=" | ðŸ“± TAP MORE CARDS FOR MULTI-SELECT")}const t=document.getElementById("turn-info");t.textContent=e,updateAIThinkingUI(),gameState.selectedCards&&gameState.selectedCards.length>0?(t.style.color="#ffa500",t.style.fontWeight="bold",t.style.textShadow="0 0 8px rgba(255, 165, 0, 0.8)"):(t.style.color="white",t.style.fontWeight="bold",t.style.textShadow="2px 2px 4px rgba(0, 0, 0, 0.8)"),updateHand(),updatePlayerStats()}function updateAIThinkingUI(){let e=document.getElementById("ai-thinking");if(e||(e=document.createElement("div"),e.id="ai-thinking",e.style.cssText="\n            position: fixed;\n            top: 100px;\n            left: 20px;\n            background: rgba(0, 0, 0, 0.8);\n            color: #00ff00;\n            padding: 10px 15px;\n            border-radius: 8px;\n            font-family: 'Courier New', monospace;\n            font-size: 14px;\n            border: 2px solid #00ff00;\n            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);\n            z-index: 1000;\n            min-width: 250px;\n            display: none;\n        ",document.body.appendChild(e)),aiThinkingState.isThinking){const t=".".repeat(aiThinkingState.thinkingDots+1),a="â–ˆ".repeat(Math.floor(10*aiThinkingState.progress/aiThinkingState.maxProgress))+"â–‘".repeat(10-Math.floor(10*aiThinkingState.progress/aiThinkingState.maxProgress)),o=Math.floor((Date.now()-aiThinkingState.startTime)/100)/10;e.innerHTML=`\n            <div style="color: #ffff00; font-weight: bold;">ðŸ¤– AI Player ${aiThinkingState.player} Thinking${t}</div>\n            <div style="margin: 5px 0; color: #ffffff;">${aiThinkingState.currentAction}</div>\n            <div style="margin: 5px 0;">Progress: [${a}] ${aiThinkingState.progress}/${aiThinkingState.maxProgress}</div>\n            <div style="color: #888888; font-size: 12px;">Time: ${o}s</div>\n        `,e.style.display="block";const r=.7+.3*Math.sin(Date.now()/200);e.style.opacity=r}else e.style.display="none";const t=document.getElementById("phase-toggle-btn");"setup"===gameState.phase?t.textContent="Switch to Play":t.textContent="Switch to Setup",updateAllAIButtons(),updateCanvas()}function updateHand(){const e=document.getElementById("hand-cards");e.innerHTML="";gameState.players[gameState.currentPlayer].hand.forEach(t=>{const a=createCardElement(t,!1);gameState.selectedCard&&gameState.selectedCard.id===t.id&&a.classList.add("selected"),e.appendChild(a)});const t=document.createElement("div");t.className="card end-turn-card",t.style.backgroundColor="transparent",t.style.color="#FF6B6B",t.style.display="flex",t.style.alignItems="center",t.style.justifyContent="center",t.style.fontSize="8px",t.style.fontWeight="bold",t.style.cursor="pointer",t.style.border="2px solid #FF6B6B",t.style.borderRadius="4px",t.style.textAlign="center",t.style.lineHeight="1.2",t.innerHTML="END<br>TURN",t.addEventListener("click",e=>{e.stopPropagation(),endTurn()}),e.appendChild(t)}function updatePlayerStats(){for(let e=1;e<=2;e++){const t=gameState.players[e],a=1===e?2:1,o=gameState.players[a];document.getElementById(`p${e}-captured-count`).textContent=o.captured.length,document.getElementById(`p${e}-discarded-count`).textContent=t.discarded.length,document.getElementById(`p${e}-deck-count`).textContent=t.deck.length}}function resetGame(){localStorage.setItem("tcg-has-interacted","true"),clearAllFadeAnimations(),gameState={currentPlayer:1,phase:"setup",turn:1,board:Array(11).fill().map(()=>Array(11).fill(null)),players:{1:{hand:[],captured:[],discarded:[],deck:[],leader:null,leaderPosition:null},2:{hand:[],captured:[],discarded:[],deck:[],leader:null,leaderPosition:null}},selectedCard:null,selectedHex:null,selectedCards:[],validMoves:[],validAttacks:[],blockedMoves:[],absorptions:[],setupStep:"place-cards",setupCardsPlaced:{1:0,2:0},setupLeaderPlaced:{1:!1,2:!1},leaderAttackedThisTurn:!1,cardsMovedThisTurn:new Set,cardsAttackedThisTurn:new Set,cardsAttackExhaustion:new Map,moveCount:1,firstPlayer:1},gameHistory=[],clearSavedGame(),initGame(!0),showSetupCaption(),updateScreenWakeLock();const e=document.getElementById("menu-options");e&&!e.classList.contains("hidden")&&e.classList.add("hidden")}function toggleMenu(){document.getElementById("menu-options").classList.toggle("hidden")}function handleMenuClose(e){const t=document.getElementById("menu-options"),a=(document.getElementById("menu-btn"),document.getElementById("settings-menu"));if(!t.classList.contains("hidden")){let o=e.target;if("touchend"===e.type&&e.changedTouches&&e.changedTouches.length>0){const t=e.changedTouches[0];o=document.elementFromPoint(t.clientX,t.clientY)}o&&!a.contains(o)&&(t.classList.add("hidden"),console.log("Menu closed by tapping outside"))}}function handleCardDragStart(e,t){if(t.owner!==gameState.currentPlayer||"setup"!==gameState.phase&&isCardExhausted(t))e.preventDefault();else{e.target.getBoundingClientRect();if(startHandCardDrag(t,e.clientX,e.clientY),draggedCard=t,e.dataTransfer.effectAllowed="move",e.dataTransfer.setData("text/plain",t.id),"play"===gameState.phase){if(!findCardPosition(t)){const e=findLeaderPosition(gameState.currentPlayer);if(e&&!gameState.leaderAttackedThisTurn){const t=countCardsOnMap(gameState.currentPlayer);if(t.leaderCount>=1&&t.regularCards>=5){const t=getHexNeighbors(e[0],e[1]);gameState.validMoves=t.filter(([e,t])=>{const a=gameState.board[e][t];return a&&a.owner===gameState.currentPlayer})}else{const t=getHexNeighbors(e[0],e[1]);gameState.validMoves=t.filter(([e,t])=>{const a=gameState.board[e][t];return!a||a.owner===gameState.currentPlayer})}updateCanvas()}}}}}function handleCardDragEnd(e){if(draggedCard&&"play"===gameState.phase){findCardPosition(draggedCard)||(gameState.validMoves=[],updateCanvas())}draggedCard=null,hoveredHex?updateCursor(hoveredHex[0],hoveredHex[1]):updateCursor(null,null)}function handleMapDragStart(e){if(0===e.button){const t=getCanvasCoordinates(e),a=pixelToHex(t.x,t.y);if(a&&gameState.board[a.row][a.col]){const e=gameState.board[a.row][a.col];if(e.owner===gameState.currentPlayer)return draggedCard=e,void(canvas.style.cursor="grabbing")}draggedCard||(isDraggingMap=!0,mapDragStartX=e.clientX,mapDragStartY=e.clientY,updateCursor(null,null))}}function handleMapDrag(e){if(isDraggingMap){e.preventDefault();let t=e.clientX-mapDragStartX,a=e.clientY-mapDragStartY;mapRotated&&(t=-t,a=-a),boardOffsetX+=t,boardOffsetY+=a,mapDragStartX=e.clientX,mapDragStartY=e.clientY,updateCanvas()}}function handleMapDragEnd(e){if(isDraggingMap&&(isDraggingMap=!1,hoveredHex?updateCursor(hoveredHex[0],hoveredHex[1]):updateCursor(null,null)),draggedCard){const t=document.getElementById("player-hand").getBoundingClientRect();if(e.clientX>=t.left&&e.clientX<=t.right&&e.clientY>=t.top&&e.clientY<=t.bottom){findCardPosition(draggedCard)&&draggedCard.owner===gameState.currentPlayer&&returnCardToHand(draggedCard)}draggedCard=null,canvas.style.cursor="pointer"}}function handleMapZoom(e){e.preventDefault();const t=canvas.getBoundingClientRect(),a=e.clientX-t.left,o=e.clientY-t.top,r=(a-boardOffsetX)/hexSize,n=(o-boardOffsetY)/hexSize,s=e.deltaY>0?.9:1.1;zoomLevel*=s,zoomLevel=Math.max(.5,Math.min(3,zoomLevel)),hexSize=baseHexSize*zoomLevel,hexWidth=2*hexSize,hexHeight=hexSize*Math.sqrt(3);boardOffsetX+=((a-boardOffsetX)/hexSize-r)*hexSize,boardOffsetY+=((o-boardOffsetY)/hexSize-n)*hexSize,drawGame()}document.addEventListener("DOMContentLoaded",()=>{initGame()}),window.addEventListener("beforeunload",()=>{releaseWakeLock(),stopKeepAlive()}),window.addEventListener("resize",()=>{const e=document.getElementById("hex-canvas"),t=e.parentElement.getBoundingClientRect(),a=Math.min(t.width-40,800),o=Math.min(t.height-40,600);e.style.width=a+"px",e.style.height=600*o/800+"px"});let touchStartTime=0,touchStartPos=null,lastTouchPos=null,lastTouchDistance=null;function handleTouchStart(e){if(!(handMobileDragState.isDragging||mobileDragState.isDragging||handDesktopDragState.isDragging||desktopDragState.isDragging))if(e.preventDefault(),1===e.touches.length){const t=e.touches[0];touchStartTime=Date.now(),touchStartPos={x:t.clientX,y:t.clientY},lastTouchPos={x:t.clientX,y:t.clientY};handleMouseDown(new MouseEvent("mousedown",{clientX:t.clientX,clientY:t.clientY,button:0}))}else 2===e.touches.length&&(isDraggingMap=!1,draggedCard=null,lastTouchDistance=getTouchDistance(e.touches[0],e.touches[1]))}function handleTouchMove(e){if(!(handMobileDragState.isDragging||mobileDragState.isDragging||handDesktopDragState.isDragging||desktopDragState.isDragging))if(e.preventDefault(),1===e.touches.length&&lastTouchPos){const t=e.touches[0];handleMouseMove(new MouseEvent("mousemove",{clientX:t.clientX,clientY:t.clientY})),lastTouchPos={x:t.clientX,y:t.clientY}}else if(2===e.touches.length){const t=getTouchDistance(e.touches[0],e.touches[1]);if(lastTouchDistance){zoomLevel*=t/lastTouchDistance>1?1.005:.995,zoomLevel=Math.max(.5,Math.min(3,zoomLevel)),hexSize=baseHexSize*zoomLevel,hexWidth=2*hexSize,hexHeight=hexSize*Math.sqrt(3),drawGame()}lastTouchDistance=t}}function handleTouchEnd(e){if(handMobileDragState.isDragging||mobileDragState.isDragging||handDesktopDragState.isDragging||desktopDragState.isDragging)return;const t=document.getElementById("menu-options"),a=document.getElementById("settings-menu");if(!t.classList.contains("hidden")&&e.changedTouches&&e.changedTouches.length>0){const o=e.changedTouches[0],r=document.elementFromPoint(o.clientX,o.clientY);if(r&&!a.contains(r))return t.classList.add("hidden"),console.log("Menu closed by mobile tap outside"),void e.preventDefault()}if(e.preventDefault(),0===e.touches.length){const e=Date.now()-touchStartTime,t=lastTouchPos&&touchStartPos?Math.sqrt(Math.pow(lastTouchPos.x-touchStartPos.x,2)+Math.pow(lastTouchPos.y-touchStartPos.y,2)):0;if(e<300&&t<10&&touchStartPos){const e=getCanvasCoordinates({clientX:touchStartPos.x,clientY:touchStartPos.y}),t=pixelToHex(e.x,e.y);if(t&&handleMobileTap(t.row,t.col))return;handleCanvasClick(new MouseEvent("click",{clientX:touchStartPos.x,clientY:touchStartPos.y}))}if(lastTouchPos){handleMouseUp(new MouseEvent("mouseup",{clientX:lastTouchPos.x,clientY:lastTouchPos.y}))}touchStartTime=0,touchStartPos=null,lastTouchPos=null,lastTouchDistance=null}}function getTouchDistance(e,t){return Math.sqrt(Math.pow(t.clientX-e.clientX,2)+Math.pow(t.clientY-e.clientY,2))}function handleMobileTap(e,t){if("play"!==gameState.phase||!gameState.validAttacks||0===gameState.validAttacks.length)return!1;return gameState.validAttacks.some(([a,o])=>a===e&&o===t)?isMobileHovering&&mobileHoveredHex&&mobileHoveredHex[0]===e&&mobileHoveredHex[1]===t?(clearMobileHover(),!1):(setMobileHover(e,t),!0):!!isMobileHovering&&(clearMobileHover(),!1)}function setMobileHover(e,t){mobileHoveredHex=[e,t],isMobileHovering=!0,hoveredHex=[e,t],hoveredAttackTarget=[e,t],attackPreviewResults=calculateAttackResults(e,t),updateCanvas()}function clearMobileHover(){mobileHoveredHex=null,isMobileHovering=!1,hoveredHex=null,hoveredAttackTarget=null,attackPreviewResults=null,updateCanvas()}function countCardsOnMap(e){let t=0,a=0;for(let o=0;o<11;o++)for(let r=0;r<11;r++){const n=gameState.board[o][r];n&&n.owner===e&&(t++,"joker"===n.suit&&a++)}return{totalCards:t,leaderCount:a,regularCards:t-a}}function placeCard(e,t,a){if(console.log(`[AI DEBUG] placeCard - Card: ${e?.value}${e?.suit}, Position: [${t},${a}], Phase: ${gameState.phase}, Player: ${gameState.currentPlayer}`),!isValidHex(t,a))return console.log("Cannot place card on invalid hex position"),!1;const o=null!==findCardPosition(e);if(!o){const o="joker"===e.suit,r=countCardsOnMap(e.owner);if("setup"===gameState.phase){const t=gameState.setupLeaderPlaced[e.owner],a=gameState.setupCardsPlaced[e.owner];if(o&&t)return console.log("Cannot place more than 1 Leader"),!1;if(!o&&a-(t?1:0)>=5)return console.log("Cannot place more than 5 regular cards"),!1;if(a>=6)return console.log("Cannot place more than 6 total cards (1 Leader + 5 regular)"),!1}else{const n=gameState.board[t][a],s=n&&n.owner===e.owner;if(o&&r.leaderCount>=1)return console.log("Cannot place more than 1 Leader on the map"),!1;if(!o&&r.regularCards>=5&&!s)return console.log("Cannot place more than 5 regular cards on the map (can only replace existing cards)"),!1;if(r.totalCards>=6&&!s)return console.log("Cannot place more than 6 total cards on the map (can only replace existing cards)"),!1}}if("play"===gameState.phase&&!o){const o=findLeaderPosition(e.owner);if(!o)return console.log("Cannot place card: no leader on board"),!1;const[r,n]=o;if(!getHexNeighbors(r,n).some(([e,o])=>e===t&&o===a))return console.log(`Cannot place card: position [${t},${a}] is not adjacent to leader at [${r},${n}]`),!1;if(gameState.leaderAttackedThisTurn)return console.log("Cannot place card: leader has already been used this turn"),!1;console.log(`[AI DEBUG] Leader adjacency check passed for position [${t},${a}] adjacent to leader at [${r},${n}]`)}const r=findCardPosition(e);if(r?gameState.board[r[0]][r[1]]=null:gameState.players[e.owner].hand=gameState.players[e.owner].hand.filter(t=>t.id!==e.id),gameState.board[t][a]&&gameState.board[t][a].owner===e.owner){const o=gameState.board[t][a];startReplacementAnimation(o,e,[t,a]),"setup"===gameState.phase?gameState.players[e.owner].hand.push(o):protectLeaderFromRemoval(o,"replacement discard")?gameState.players[e.owner].discarded.push(o):(console.warn("Leader discard blocked during replacement - returning to hand instead"),gameState.players[e.owner].hand.push(o))}if("play"!==gameState.phase||r||(e.faceDown=!0,console.log(`Card ${e.value}${e.suit} summoned face down`)),gameState.board[t][a]=e,"joker"===e.suit&&(gameState.players[e.owner].leaderPosition=[t,a],"setup"===gameState.phase&&(gameState.setupLeaderPlaced[e.owner]=!0)),"setup"===gameState.phase){gameState.setupCardsPlaced[e.owner]++;const t=gameState.setupLeaderPlaced[1]&&gameState.setupCardsPlaced[1]>=6,a=gameState.setupLeaderPlaced[2]&&gameState.setupCardsPlaced[2]>=6;t&&a?(gameState.phase="play",gameState.currentPlayer=determineFirstPlayer(),updateMapRotation(),startNewTurn()):(updateBoardCardOverlays(),endTurn())}else if("play"===gameState.phase&&!o){gameState.leaderAttackedThisTurn=!0,console.log(`[AI DEBUG] Leader marked as used this turn for card placement at [${t},${a}]`);const o=findLeaderPosition(gameState.currentPlayer);if(o){const e=gameState.board[o[0]][o[1]];if(e&&"joker"===e.suit){gameState.cardsMovedThisTurn.has(e.id)&&(gameState.cardsAttackedThisTurn.add(e.id),console.log("Leader marked as exhausted after summon (already moved this turn)"))}}updateBoardCardOverlays(),e.owner!==gameState.currentPlayer||aiEnabled[gameState.currentPlayer]||setTimeout(()=>{const o=!gameState.cardsAttackedThisTurn.has(e.id)&&getValidAttacks(e,t,a).length>0,r=!gameState.cardsMovedThisTurn.has(e.id)&&getValidMoves(e,t,a).length>0;o||r?(selectCard(e,t,a),console.log(`Auto-selected ${e.value}${e.suit} after summoning (${o?"attacks":""}${o&&r?" and ":""}${r?"movement":""} available)`)):console.log(`Skipped auto-selection of ${e.value}${e.suit} - no remaining actions`)},150)}return!0}function protectLeaderFromRemoval(e,t="unknown"){return!e||"joker"!==e.suit||(console.error(`CRITICAL PROTECTION: Blocked attempt to remove leader in context: ${t}`),console.error("Leader details:",e),console.error("Stack trace:",(new Error).stack),!1)}function ensureLeaderImmortality(){for(let e=1;e<=2;e++){const t=gameState.players[e];for(let e=t.captured.length-1;e>=0;e--){const a=t.captured[e];if(a&&"joker"===a.suit){console.error("EMERGENCY RESTORE: Found leader in captured stack! Restoring..."),t.captured.splice(e,1);let o=!1;for(let e=0;e<11&&!o;e++)for(let t=0;t<11&&!o;t++)isValidHex(e,t)&&!gameState.board[e][t]&&(gameState.board[e][t]=a,o=!0,console.log(`Leader restored to position (${e},${t})`))}}for(let e=t.discarded.length-1;e>=0;e--){const a=t.discarded[e];if(a&&"joker"===a.suit){console.error("EMERGENCY RESTORE: Found leader in discarded stack! Restoring..."),t.discarded.splice(e,1);let o=!1;for(let e=0;e<11&&!o;e++)for(let t=0;t<11&&!o;t++)isValidHex(e,t)&&!gameState.board[e][t]&&(gameState.board[e][t]=a,o=!0,console.log(`Leader restored to position (${e},${t})`))}}}}function validateLeadersOnMap(){ensureLeaderImmortality();let e=!1,t=!1;for(let a=0;a<11;a++)for(let o=0;o<11;o++){const r=gameState.board[a][o];r&&"joker"===r.suit&&(1===r.owner&&(e=!0),2===r.owner&&(t=!0))}return e?!!t||(console.error("CRITICAL ERROR: Player 2 leader missing from the map!"),console.error("Current board state:",gameState.board),!1):(console.error("CRITICAL ERROR: Player 1 leader missing from the map!"),console.error("Current board state:",gameState.board),!1)}function findCardById(e){for(let t=0;t<11;t++)for(let a=0;a<11;a++)if(gameState.board[t][a]&&gameState.board[t][a].id===e)return gameState.board[t][a];return null}function colToLetter(e){return null==e?"":String.fromCharCode(65+e)}function rowToNumber(e){return null==e?"":(e+1).toString()}function drawCoordinateOnGrid(e,t,a,o){const r=`${colToLetter(a)}${rowToNumber(o)}`;ctx.save(),ctx.font=`bold ${Math.round(12*zoomLevel)}px Arial`,ctx.fillStyle="rgba(128, 128, 128, 0.7)",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText(r,e,t),ctx.restore()}function drawBlockedSymbol(e,t){ctx.save(),ctx.font=`bold ${Math.round(16*zoomLevel)}px Arial`,ctx.fillStyle="rgba(255, 255, 255, 0.5)",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText("ðŸš«",e,t),ctx.restore()}function drawShieldSymbol(e,t){ctx.save(),ctx.font=`bold ${Math.round(20*zoomLevel)}px Arial`,ctx.fillStyle="rgba(135, 206, 250, 0.5)",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText("ðŸ›¡ï¸",e,t),ctx.restore()}function drawSkullSymbol(e,t){ctx.save(),ctx.font=`bold ${Math.round(24*zoomLevel)}px Arial`,ctx.fillStyle="rgba(255, 0, 0, 0.8)",ctx.strokeStyle="rgba(255, 255, 255, 0.9)",ctx.lineWidth=2,ctx.textAlign="center",ctx.textBaseline="middle",ctx.strokeText("ðŸ’€",e,t),ctx.fillText("ðŸ’€",e,t),ctx.restore()}function drawLeaderAttackSymbol(e,t){ctx.save(),ctx.font=`bold ${Math.round(20*zoomLevel)}px Arial`,ctx.fillStyle="rgba(255, 215, 0, 0.9)",ctx.strokeStyle="rgba(0, 0, 0, 0.8)",ctx.lineWidth=2,ctx.textAlign="center",ctx.textBaseline="middle",ctx.strokeText("-3",e,t),ctx.fillText("-3",e,t),ctx.restore()}function drawDiscardSymbol(e,t){ctx.save(),ctx.font=`bold ${Math.round(24*zoomLevel)}px Arial`,ctx.fillStyle="rgba(255, 0, 0, 0.8)",ctx.strokeStyle="rgba(255, 255, 255, 0.9)",ctx.lineWidth=2,ctx.textAlign="center",ctx.textBaseline="middle",ctx.strokeText("âœ•",e,t),ctx.fillText("âœ•",e,t),ctx.restore()}function updateCoordinateDisplay(e,t,a,o){}